{"/home/travis/build/npmtest/node-npmtest-everyauth/test.js":"/* istanbul instrument in package npmtest_everyauth */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-everyauth/lib.npmtest_everyauth.js":"/* istanbul instrument in package npmtest_everyauth */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_everyauth = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_everyauth = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-everyauth/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-everyauth && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_everyauth */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_everyauth\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_everyauth.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_everyauth.rollup.js'] =\n            local.assetsDict['/assets.npmtest_everyauth.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_everyauth.__dirname + '/lib.npmtest_everyauth.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/index.js":"var path = require('path');\nvar EventEmitter = require('events').EventEmitter;\nvar connect = require('connect');\nvar express = require('express');\nvar ExpressRouter = require('express/lib/router');\nvar __pause = connect.utils.pause;\nvar merge = require('./lib/utils').merge;\n\nvar everyauth = module.exports = {};\n\n\neveryauth.helpExpress = function () {\n  console.warn('everyauth.helpExpress is being deprecated. helpExpress is now automatically invoked when it detects express. So remove everyauth.helpExpress from your code');\n  return this;\n};\n\neveryauth.debug = false;\n\n// The connect middleware. e.g.,\n//     connect(\n//         ...\n//       , everyauth.middleware()\n//       , ...\n//     )\neveryauth.middleware = function (opts) {\n  opts = merge({\n    autoSetupRoutes: true\n  }, opts);\n  var userAlias = everyauth.expressHelperUserAlias || 'user';\n  var router = new ExpressRouter;\n\n  if (opts.autoSetupRoutes) {\n    var router = new ExpressRouter();\n    var modules = everyauth.enabled;\n    for (var _name in modules) {\n      var _module = modules[_name];\n      _module.validateSequences();\n      _module.routeApp(router);\n    }\n  }\n\n  return function (req, res, next) {\n    fetchUserFromSession(req, function (err) {\n      addRequestLocals(req, res, userAlias);\n      registerReqGettersAndMethods(req);\n      if (router) {\n        router._dispatch(req, res, next);\n      } else {\n        next();\n      }\n    });\n  }\n};\n\nfunction addRequestLocals (req, res, userAlias) {\n  if (res.locals) {\n    var session = req.session;\n    var auth = session && session.auth;\n    var everyauthLocal = merge(auth, {\n      loggedIn: !! (auth && auth.loggedIn)\n    , user: req.user\n    });\n\n    if (everyauth.enabled.password) {\n      // Add in access to loginFormFieldName() + passwordFormFieldName()\n      everyauthLocal.password || (everyauthLocal.password = {});\n      everyauthLocal.password.loginFormFieldName = everyauth.password.loginFormFieldName();\n      everyauthLocal.password.passwordFormFieldName = everyauth.password.passwordFormFieldName();\n    }\n    res.locals.everyauth = everyauthLocal;\n    res.locals[userAlias] = req.user;\n  }\n}\n\nfunction registerReqGettersAndMethods (req) {\n  var methods = everyauth._req._methods\n  var getters = everyauth._req._getters;\n  for (var name in methods) {\n    req[name] = methods[name];\n  }\n  for (name in getters) {\n    Object.defineProperty(req, name, {\n      get: getters[name]\n    });\n  }\n}\n\nfunction fetchUserFromSession (req, callback) {\n  var session = req.session\n  var auth = session && session.auth;\n  if (!auth || !auth.userId) return callback();\n  var everymodule = everyauth.everymodule;\n  var pause = __pause(req);\n\n  var findUserById_function = everymodule.findUserById();\n\n  findUserById_function.length === 3\n    ? findUserById_function( req, auth.userId, findUserById_callback )\n    : findUserById_function(      auth.userId, findUserById_callback );\n\n  function findUserById_callback (err, user) {\n    if (err) {\n      pause.resume();\n      return callback(err);\n    }\n    if (user) req.user = user;\n    else delete session.auth;\n    callback();\n    pause.resume();\n  }\n}\n\neveryauth._req = {\n    _methods: {}\n  , _getters: {}\n};\n\neveryauth.addRequestMethod = function (name, fn) {\n  this._req._methods[name] = fn;\n  return this;\n};\n\neveryauth.addRequestGetter = function (name, fn, isAsync) {\n  this._req._getters[name] = fn;\n  return this;\n};\n\neveryauth\n  .addRequestMethod('logout', function () {\n    var req = this;\n    delete req.session.auth;\n  })\n  .addRequestGetter('loggedIn', function () {\n    var req = this;\n    return !!(req.session && req.session.auth && req.session.auth.loggedIn);\n  });\n\neveryauth.modules = {};\neveryauth.enabled = {};\n\n// Grab all filenames in ./modules -- They correspond to the modules of the same name\n// as the filename (minus '.js')\nvar fs = require('fs');\nvar files = fs.readdirSync(__dirname + '/lib/modules').filter( function (file) {\n  return path.extname(file) === '.js';\n});\nvar includeModules = files.map( function (fname) {\n  return path.basename(fname, '.js');\n});\nfor (var i = 0, l = includeModules.length; i < l; i++) {\n  var name = includeModules[i];\n\n  // Lazy enabling of a module via `everyauth` getters\n  // i.e., the `facebook` module is not loaded into memory\n  // until `everyauth.facebook` is evaluated\n  Object.defineProperty(everyauth, name, {\n    get: (function (name) {\n      return function () {\n        var mod = this.modules[name] || (this.modules[name] = require('./lib/modules/' + name));\n        // Make `everyauth` accessible from each auth strategy module\n        if (!mod.everyauth) mod.everyauth = this;\n        if (mod.shouldSetup)\n          this.enabled[name] = mod;\n        return mod;\n      }\n    })(name)\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/utils.js":"var tls = require('tls');\n\nmodule.exports = {\n  clone: clone\n, extractHostname: extractHostname\n, merge: merge\n};\n\nfunction clone (obj) {\n  if (obj === undefined || obj === null)\n    return obj\n  if (Array.isArray(obj))\n    return cloneArray(obj);\n  if (obj.constructor == Object)\n    return cloneObject(obj);\n  return obj;\n}\n\nfunction cloneObject (obj, shouldMinimizeData) {\n  var ret = {};\n  for (var k in obj)\n    ret[k] = clone(obj[k]);\n  return ret;\n}\n\nfunction cloneArray (arr) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++)\n    ret.push(clone(arr[i]));\n  return ret;\n}\n\nfunction extractHostname (req) {\n  var headers = req.headers\n    , protocol = (req.connection.server instanceof tls.Server ||\n                 (req.headers['x-forwarded-proto'] && req.headers['x-forwarded-proto'].slice(0,5) === 'https'))\n               ? 'https://'\n               : 'http://'\n    , host = headers.host;\n  return protocol + host;\n}\n\nfunction merge () {\n  var mergeInto = {};\n  for (var i = 0, l = arguments.length, mergeFrom, k; i < l; i++) {\n    mergeFrom = arguments[i];\n    for (k in mergeFrom) {\n      mergeInto[k] = mergeFrom[k];\n    }\n  }\n  return mergeInto;\n}\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/promise.js":"var Promise = function (values) {\n  this._callbacks = [];\n  this._errbacks = [];\n  this._timebacks = [];\n  if (arguments.length > 0) {\n    this.fulfill.apply(this, values);\n  }\n};\n\nPromise.prototype.callback = function (fn, scope) {\n  if (this.values) {\n    fn.apply(scope, this.values);\n    return this;\n  }\n  this._callbacks.push([fn, scope]);\n  return this;\n};\n\nPromise.prototype.errback = function (fn, scope) {\n  if (this.err) {\n    fn.call(scope, this.err);\n    return this;\n  }\n  this._errbacks.push([fn, scope]);\n  return this;\n};\n\nPromise.prototype.timeback = function (fn, scope) {\n  if (this.timedOut) {\n    fn.call(scope);\n    return this;\n  }\n  this._timebacks.push([fn, scope]);\n  return this;\n};\n\nPromise.prototype.fulfill = function () {\n  if (this.isFulfilled || this.err || this.timedOut) return;\n  this.isFulfilled = true;\n  if (this._timeout) clearTimeout(this._timeout);\n  var callbacks = this._callbacks;\n  this.values = arguments;\n  for (var i = 0, l = callbacks.length; i < l; i++) {\n    callbacks[i][0].apply(callbacks[i][1], arguments);\n  }\n  return this;\n};\n\nPromise.prototype.fail = function (err) {\n  if (this._timeout) clearTimeout(this._timeout);\n  var errbacks = this._errbacks;\n  if ('string' === typeof err)\n    err = new Error(err);\n  this.err = err;\n  for (var i = 0, l = errbacks.length; i < l; i++) {\n    errbacks[i][0].call(errbacks[i][1], err);\n  }\n  return this;\n};\n\nPromise.prototype.timeout = function (ms) {\n  if (this.values || this.err) return this;\n  var timebacks = this._timebacks\n    , self = this;\n  if (ms === -1) return this;\n  this._timeout = setTimeout(function () {\n    self.timedOut = true;\n    for (var i = 0, l = timebacks.length; i < l; i++) {\n      timebacks[i][0].call(timebacks[i][1]);\n    }\n  },  ms);\n  return this;\n};\n\nvar ModulePromise = module.exports = function (_module, values) {\n  if (values)\n    Promise.call(this, values);\n  else\n    Promise.call(this);\n  this.module = _module;\n};\n\nModulePromise.prototype.__proto__ = Promise.prototype;\n\nModulePromise.prototype.breakTo = function (seqName) {\n  if (this._timeout) clearTimeout(this._timeout);\n\n  var args = Array.prototype.slice.call(arguments, 1);\n  var _module = this.module\n    , seq = _module._stepSequences[seqName];\n  if (_module.everyauth.debug)\n    console.log('breaking out to ' + seq.name);\n  seq = seq.materialize();\n  seq.start.apply(seq, args);\n  // TODO Garbage collect the abandoned sequence\n};\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/routeTriggeredSequence.js":"var StepSequence = require('./stepSequence');\n\nmodule.exports = RouteTriggeredSequence;\n\nfunction RouteTriggeredSequence (name, _module) {\n  StepSequence.call(this, name, _module);\n}\n\nrequire('util').inherits(RouteTriggeredSequence, StepSequence);\n\nRouteTriggeredSequence.prototype.routeHandler = function (req, res, next) {\n  // Create a shallow clone, so that seq.values are different per HTTP request\n  var seq = this.materialize();\n  // Kicks off a sequence of steps based on a route\n  seq.start(req, res, next); // BOOM!\n};\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/stepSequence.js":"var Promise = require('./promise');\nvar clone = require('./utils').clone;\n\nmodule.exports = StepSequence;\n\nfunction StepSequence (name, module) {\n  this.name = name;\n  this.module = module;\n  this.orderedStepNames = [];\n}\n\nStepSequence.prototype.isSeq = true;\n\n/**\n * Sets up the immediate or eventual output of priorPromise to pipe to the\n * nextStep's promise\n * @param {Promise} priorPromise\n * @param {Step} nextStep\n * @returns {Promise}\n */\nStepSequence.prototype._bind = function (priorPromise, nextStep) {\n  var nextPromise = new Promise();\n  var seq = this;\n\n  priorPromise.callback( function () {\n    var resultPromise = nextStep.exec(seq);\n    if (!resultPromise) return; // if we have a breakTo\n    resultPromise.callback( function () {\n      nextPromise.fulfill();\n    }); // TODO breakback?\n  });\n  return nextPromise;\n};\n\n/**\n * This kicks off a sequence of steps.\n * Creates a new chain of promises and exposes the leading promise\n * to the incoming (req, res) pair from the route handler\n */\nStepSequence.prototype.start = function () {\n  var steps = this.steps;\n\n  this._transposeArgs(arguments);\n\n  // Pipe through the steps\n  var priorStepPromise = steps[0].exec(this);\n\n  // If we have a breakTo\n  if (!priorStepPromise) return;\n\n  for (var i = 1, l = steps.length; i < l; i++) {\n    priorStepPromise = this._bind(priorStepPromise, steps[i]);\n  }\n  return priorStepPromise;\n};\n\n// Used for exposing the leading promise of a step promise chain to the\n// incoming args (e.g., [req, res] pair from the route handler)\nStepSequence.prototype._transposeArgs = function (args) {\n  var seq = this;\n  this.steps[0].accepts.forEach( function (paramName, i) {\n    // Map the incoming arguments to the named parameters \n    // that the first step is expected to accept.\n    seq.values[paramName] = args[i];\n  });\n};\n\nStepSequence.prototype.clone = function (submodule) {\n  var sequence = new (this.constructor)(this.name, submodule);\n  sequence.orderedStepNames = clone(this.orderedStepNames);\n  return sequence;\n};\n\nStepSequence.prototype._propertiesToMaterialize = ['isSeq', '_bind', 'start', '_transposeArgs'];\n\nStepSequence.prototype.materialize = function () {\n  var sequence = Object.create(this)\n    , materializedMethods = this._propertiesToMaterialize;\n  sequence.values = {};\n  for (var i = materializedMethods.length; i--;) {\n    var methodName = materializedMethods[i];\n    sequence[methodName] = this[methodName];\n  }\n  return sequence;\n};\n\n// TODO Replace logic here with newer introspection code\nStepSequence.prototype.validateSteps = function () {\n  var steps = this.steps\n    , step\n    , paramsToDate = []\n    , missingParams;\n  for (var i = 0, l = steps.length; i < l; i++) {\n    step = steps[i];\n    if ('undefined' === typeof step.accepts)\n      throw new Error('You did not declare accepts for the step: ' + step.name);\n    if ('undefined' === typeof step.promises)\n      throw new Error('You did not declare promises for the step: ' + step.name);\n\n    if (i === 0) \n      paramsToDate = paramsToDate.concat(step.accepts);\n\n    missingParams = step.accepts.filter( function (param) {\n      return paramsToDate.indexOf(param) === -1;\n    });\n\n    if (i > 0 && missingParams.length)\n      throw new Error('At step, ' + step.name + ', you are trying to access the parameters: ' +\n        missingParams.join(', ') + ' . However, only the following parameters have been ' +\n        'promised from prior steps thus far: ' + paramsToDate.join(', '));\n\n    paramsToDate = paramsToDate.concat(step.promises);\n\n    if ('undefined' === typeof this.module[step.name]())\n      // TODO Remove this Error, since invoking the arg to typeof (see line above)\n      //      already throws an Error\n      throw new Error('No one defined the function for the following step: ' + step.name + ' in the module ' + this.module.name);\n  }\n};\n\nObject.defineProperty(StepSequence.prototype, 'steps', {\n  get: function () {\n    // Compile the steps by pulling the step names from the module\n    var allSteps = this.module._steps\n      , orderedSteps = this.orderedStepNames.map( function (stepName) {\n          return allSteps[stepName];\n        })\n      , seq = this;\n\n    function compileSteps () {\n      var paramsToDate = []\n        , missingParams;\n\n      var steps = orderedSteps.map( function (step, i) {\n        var meta = { missing: [], step: step, missingParams: [], paramsToDate: {} };\n        if (! ('promises' in step)) {\n          meta.missing.push('promises');\n        }\n        if (! ('accepts' in step)) {\n          meta.missing.push('accepts');\n        }\n\n        if (('accepts' in step) && i === 0)\n          paramsToDate = paramsToDate.concat(step.accepts);\n\n        missingParams = !step.accepts ? [] : step.accepts.filter( function (param) {\n          return paramsToDate.indexOf(param) === -1;\n        });\n\n        if (step.promises)\n          paramsToDate = paramsToDate.concat(step.promises);\n\n        if (missingParams.length) {\n          meta.missingParams = missingParams;\n          meta.paramsToDate = paramsToDate;\n        }\n\n        if (! (('_' + step.name) in seq.module))\n          meta.missing.push('its function');\n\n        return meta;\n      });\n\n      return steps;\n    }\n\n    var compiledSteps;\n\n    Object.defineProperty(orderedSteps, 'incomplete', { get: function () {\n      compiledSteps || (compiledSteps = compileSteps());\n      return compiledSteps.filter( function (stepMeta) {\n        return stepMeta.missing.length > 0;\n      }).map( function (stepMeta) {\n        var error = 'is missing: ' + stepMeta.missing.join(', ');\n        return { name: stepMeta.step.name, error: error };\n      });\n    } });\n\n    Object.defineProperty(orderedSteps, 'invalid', { get: function () {\n      compiledSteps || (compiledSteps = compileSteps());\n      return compiledSteps.filter( function (stepMeta) {\n        return stepMeta.missingParams.length > 0;\n      }).map( function (stepMeta) {\n        var error = 'is trying to accept the parameters: ' + \n                  stepMeta.missingParams.join(', ') + \n                  ' . However, only the following parameters have ' + \n                  'been promised from prior steps thus far: ' + \n                  stepMeta.paramsToDate.join(', ');\n        return { name: stepMeta.step.name, error: error };\n      });\n    } });\n\n    return orderedSteps;\n  }\n});\n\nObject.defineProperty(StepSequence.prototype, 'debug', {\n  get: function () { return this.module.everyauth.debug; }\n});\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/step.js":"var Promise = require('./promise');\nvar clone = require('./utils').clone;\n\nmodule.exports = Step;\n\nfunction Step (name, _module) {\n  this.name = name;\n\n  // defineProperty; otherwise,\n  // clone will overflow when we clone a module\n  Object.defineProperty(this, 'module', { value: _module });\n}\n\n/**\n * @returns {Promise}\n */\nStep.prototype.exec = function (seq) {\n  var accepts = this.accepts;\n  var promises = this.promises;\n  var block = this.block;\n  var _module = this.module;\n  var stepName = this.name;\n  var step = this;\n  function errorCallback (error) {\n    // Ensure that seq.values are always passed back to moduleErrback\n    if (step.errback) {\n      step.errback(error, seq.values);\n    } else if (_module._moduleErrback) {\n      _module._moduleErrback(error, seq.values);\n    } else {\n      throw new Error('Missing module or step errback');\n    }\n  }\n\n\n  if (this.debug) {\n    console.log('starting step - ' + this.name);\n  }\n\n  var args = this._unwrapArgs(seq);\n\n  // There is a hidden last argument to every step function that\n  // is all the data promised by prior steps up to the step's point\n  // in time. We cannot anticipate everything a developer may want via\n  // `accepts(...)`. Therefore, just in case, we give the developer\n  // access to all data promised by prior steps via the last argument -- `seq.values`\n  args.push(seq.values);\n\n  var ret;\n  try {\n    // Apply the step logic\n\n    // Add _super access\n    _module._super = function () {\n      var step = this.__proto__._steps[stepName];\n      if (!step) return;\n      var superArgs = arguments.length ? arguments : args;\n      step.block.apply(this, superArgs);\n    };\n    ret = block.apply(_module, args);\n    delete _module._super;\n  } catch (breakTo) {\n    // Catch any sync breakTo's if any\n    if (breakTo.isSeq) {\n      if (this.module.everyauth.debug)\n        console.log(\"breaking out to \" + breakTo.name);\n      breakTo.start.apply(breakTo, breakTo.initialArgs);\n      // TODO Garbage collect the promise chain\n      return;\n    } else {\n      // Else, we have a regular exception\n      errorCallback(breakTo);\n    }\n  }\n\n  if (promises && promises.length &&\n        'undefined' === typeof ret) {\n    errorCallback(\n      new Error('Step ' + this.name + ' of `' + _module.name +\n        '` is promising: ' +  promises.join(', ') +\n        ' ; however, the step returns nothing. ' +\n        'Fix the step by returning the expected values OR ' +\n        'by returning a Promise that promises said values.')\n    );\n  }\n  // Convert return value into a Promise\n  // if it's not yet a Promise\n  ret = (ret instanceof Promise)\n      ? ret\n      : Array.isArray(ret)\n        ? promises.length === 1\n          ? this.module.Promise([ret])\n          : this.module.Promise(ret)\n        : this.module.Promise([ret]);\n\n  if (seq.debug) {\n    ret.callback( function () {\n      console.log('...finished step');\n    });\n  }\n\n  var convertErr = _module._convertErr;\n  if (convertErr) {\n    var oldErrback = ret.errback;\n    ret.errback = function (fn, scope) {\n      var oldFn = fn;\n      fn = function (err) {\n        if (err.constructor === Object) {\n          err = convertErr(err);\n        } else if ('string' === typeof err) {\n          err = new Error(err);\n        }\n        return oldFn.call(this, err);\n      };\n      return oldErrback.call(this, fn, scope);\n    };\n  }\n\n  ret.errback(errorCallback);\n\n  ret.callback( function () {\n    // Store the returned values\n    // in the sequence's state via seq.values\n    var returned = arguments\n      , vals = seq.values;\n    if (promises !== null) promises.forEach( function (valName, i) {\n      vals[valName] = returned[i];\n    });\n  });\n\n  ret.timeback( function () {\n    ret.fail(new Error('Step ' + stepName + ' of `' + _module.name + '` module timed out.'));\n  });\n\n  var timeoutMs = this.timeout || _module.moduleTimeout();\n  ret.timeout(timeoutMs);\n\n  return ret;\n};\n\n/**\n * Unwraps values (from the sequence) based on\n * the step's this.accepts spec.\n */\nStep.prototype._unwrapArgs = function (seq) {\n  return this.accepts.reduce( function (args, accept) {\n    args.push(seq.values[accept]);\n    return args;\n  }, []);\n};\n\nStep.prototype.clone = function (name, _module) {\n  var step = new Step(name, _module);\n  step.accepts = clone(this.accepts);\n  step.promises = clone(this.promises);\n  step.description = this.description;\n  step.timeout = this.timeout;\n  step.errback = this.errback;\n  return step;\n};\n\nObject.defineProperty(Step.prototype, 'block', {\n  get: function () {\n    return this._block || (this._block = this.module[this.name]());\n  }\n});\n\nObject.defineProperty(Step.prototype, 'debug', {\n  get: function () {\n    return this.module.everyauth.debug;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/37signals.js":"var oauthModule = require('./oauth2');\n\nmodule.exports =\noauthModule.submodule('37signals')\n  .configurable({\n      scope: 'specify types of access: (no scope), user, public_repo, repo, gist'\n  })\n\n  .oauthHost('https://launchpad.37signals.com')\n  .apiHost('https://launchpad.37signals.com')\n\n  .authPath('/authorization/new')\n  .authQueryParam('type', 'web_server')\n\n  .accessTokenPath('/authorization/token')\n  .accessTokenParam('type', 'web_server')\n\n  .postAccessTokenParamsVia('data')\n\n  .entryPath('/auth/37signals')\n  .callbackPath('/auth/37signals/callback')\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/authorization.json', accessToken, function (err, data) {\n      if (err) return p.fail(err);\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    })\n    return p;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var _37sigResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          _37sigResponse.statusCode\n        , _37sigResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/oauth2.js":"var everyModule = require('./everymodule')\n  , OAuth = require('oauth').OAuth2\n  , url = require('url')\n  , querystring = require('querystring')\n  , request = require('request')\n  , extractHostname = require('../utils').extractHostname;\n\n// Steps define a sequence of logic that pipes data through\n// a chain of promises. A new chain of promises is generated\n// every time the set of steps is started.\n\nvar oauth2 = module.exports =\neveryModule.submodule('oauth2')\n  .definit( function () {\n    this.oauth = new OAuth(this._appId, this._appSecret, this._oauthHost, this._authPath, this._accessTokenPath, this._customHeaders);\n  })\n  .configurable({\n      apiHost: 'e.g., https://graph.facebook.com'\n    , oauthHost: 'the host for the OAuth provider'\n    , appId: 'the OAuth app id provided by the host'\n    , appSecret: 'the OAuth secret provided by the host'\n    , authPath: \"the path on the OAuth provider's domain where \" + \n                \"we direct the user for authentication, e.g., /oauth/authorize\"\n    , accessTokenPath: \"the path on the OAuth provider's domain \" + \n                \"where we request the access token, e.g., /oauth/access_token\"\n    , accessTokenHttpMethod: 'the http method (\"get\" or \"post\") with which to make our access token request'\n    , customHeaders: 'any cusomt headers required in the access token request'\n    , postAccessTokenParamsVia: '\"query\" to POST the params to the access ' + \n                'token endpoint as a querysting; \"data\" to POST the params to ' +\n                'the access token endpoint in the request body'\n    , myHostname: 'e.g., http://local.host:3000 . Notice no trailing slash'\n    , alwaysDetectHostname: 'does not cache myHostname once. Instead, re-detect it on every request. Good for multiple subdomain architectures'\n    , convertErr: '(DEPRECATED) a function (data) that extracts an error message from data arg, where `data` is what is returned from a failed OAuth request'\n    , authCallbackDidErr: 'Define the condition for the auth module determining if the auth callback url denotes a failure. Returns true/false.'\n  })\n\n  // Declares a GET route that is aliased\n  // as 'entryPath'. The handler for this route\n  // triggers the series of steps that you see\n  // indented below it.\n  .get('entryPath',\n       'the link a user follows, whereupon you redirect them to the 3rd party OAuth provider dialog - e.g., \"/auth/facebook\"')\n    .step('getAuthUri')\n      .accepts('req res next')\n      .promises('authUri')\n    .step('requestAuthUri')\n      .accepts('res authUri')\n      .promises(null)\n\n  .get('callbackPath',\n       'the callback path that the 3rd party OAuth provider redirects to after an OAuth authorization result - e.g., \"/auth/facebook/callback\"')\n    .step('getCode')\n      .description('retrieves a verifier code from the url query')\n      .accepts('req res next')\n      .promises('code')\n      .canBreakTo('authCallbackErrorSteps')\n    .step('getAccessToken')\n      .accepts('code')\n      .promises('accessToken extra')\n    .step('fetchOAuthUser')\n      .accepts('accessToken')\n      .promises('oauthUser')\n    .step('getSession')\n      .accepts('req')\n      .promises('session')\n    .step('findOrCreateUser')\n      //.optional()\n      .accepts('session accessToken extra oauthUser')\n      .promises('user')\n    .step('compile')\n      .accepts('accessToken extra oauthUser user')\n      .promises('auth')\n    .step('addToSession')\n      .accepts('session auth')\n      .promises(null)\n    .step('sendResponse')\n      .accepts('res')\n      .promises(null)\n\n  .stepseq('authCallbackErrorSteps')\n      .step('handleAuthCallbackError',\n           'a request handler that intercepts a failed authorization message sent from the OAuth2 provider to your service. e.g., the request handler for \"/auth/facebook/callback?error_reason=user_denied&error=access_denied&error_description=The+user+denied+your+request.\"')\n        .accepts('req res next')\n        .promises(null)\n\n  .getAuthUri( function (req, res, next) {\n\n    // Automatic hostname detection + assignment\n    if (!this._myHostname || this._alwaysDetectHostname) {\n      this.myHostname(extractHostname(req));\n    }\n\n    var params = {\n            client_id: this._appId\n          , redirect_uri: this._myHostname + this._callbackPath\n        }\n      , authPath = this._authPath\n      , url = (/^http/.test(authPath))\n            ? authPath\n            : (this._oauthHost + authPath)\n      , additionalParams = this.moreAuthQueryParams\n      , param;\n\n    if (additionalParams) for (var k in additionalParams) {\n      param = additionalParams[k];\n      if ('function' === typeof param) {\n        // e.g., for facebook module, param could be\n        // function () {\n        //   return this._scope && this.scope();\n        // }\n        param = param.call(this, req, res);\n      }\n      if ('function' === typeof param) {\n        // this.scope() itself could be a function\n        // to allow for dynamic scope determination - e.g.,\n        // function (req, res) {\n        //   return req.session.onboardingPhase; // => \"email\"\n        // }\n        param = param.call(this, req, res);\n      }\n      params[k] = param;\n    }\n    return url + '?' + querystring.stringify(params);\n  })\n  .requestAuthUri( function (res, authUri) {\n    this.redirect(res, authUri);\n  })\n  .getCode( function (req, res, next) {\n    var parsedUrl = url.parse(req.url, true);\n    if (this._authCallbackDidErr(req)) {\n      return this.breakTo('authCallbackErrorSteps', req, res, next);\n    }\n    if (!parsedUrl.query || !parsedUrl.query.code) {\n      console.error(\"Missing code in querystring. The url looks like \" + req.url);\n      return this.breakTo('authCallbackErrorSteps', req, res, next);\n    }\n    return parsedUrl.query && parsedUrl.query.code;\n  })\n  .getAccessToken( function (code, data) {\n    var p = this.Promise()\n      , params = {\n            client_id: this._appId\n          , redirect_uri: this._myHostname + this._callbackPath\n          , code: code\n          , client_secret: this._appSecret\n        }\n      , url = this._oauthHost + this._accessTokenPath\n      , additionalParams = this.moreAccessTokenParams\n      , param;\n\n    if (this._accessTokenPath.indexOf(\"://\") != -1) {\n      // Just in case the access token url uses a different subdomain\n      // than than the other urls involved in the oauth2 process.\n      // * cough * ... gowalla\n      url = this._accessTokenPath;\n    }\n\n    if (additionalParams) for (var k in additionalParams) {\n      param = additionalParams[k];\n      if ('function' === typeof param) {\n        additionalParams[k] = // cache the fn call\n          param = param.call(this, data.req, data.res);\n      }\n      if ('function' === typeof param) {\n        param = param.call(this, data.req, data.res);\n      }\n      params[k] = param;\n    }\n\n    var opts = { url: url }\n      , paramsVia = this._postAccessTokenParamsVia;\n    switch (paramsVia) {\n      case 'query': // Submit as a querystring\n        opts.headers || (opts.headers = {});\n        opts.headers['Content-Length'] = 0;\n        paramsVia = 'qs';\n        break;\n      case 'data': // Submit via application/x-www-form-urlencoded\n        paramsVia = 'form';\n        break;\n      default:\n        throw new Error('postAccessTokenParamsVia must be either \"query\" or \"data\"');\n    }\n    opts[paramsVia] = params;\n    request[this._accessTokenHttpMethod](opts, function (err, res, body) {\n      if (err) {\n        err.extra = {data: body, res: res};\n        return p.fail(err);\n      }\n      if (parseInt(res.statusCode / 100) != 2) return p.fail({extra: {res: res, data: body}});\n      var resType = res.headers['content-type']\n        , data;\n      if (resType.substring(0, 10) === 'text/plain') {\n        data = querystring.parse(body);\n      } else if (resType.substring(0, 33) === 'application/x-www-form-urlencoded') {\n        data = querystring.parse(body);\n      } else if (resType.substring(0, 16) === 'application/json') {\n        data = JSON.parse(body);\n      } else {\n        throw new Error('Unsupported content-type ' + resType);\n      }\n      var aToken = data.access_token;\n      delete data.access_token;\n      p.fulfill(aToken, data);\n    });\n\n    return p;\n  })\n  .compile( function (accessToken, extra, oauthUser, user) {\n    var compiled = {\n        accessToken: accessToken\n      , oauthUser: oauthUser\n      , user: user\n    };\n    // extra is any extra params returned by the\n    // oauth provider in response to the access token\n    // POST request\n    for (var k in extra) {\n      // avoid clobbering any of the properties we set just above (user, accessToken, oauthUser)\n      // instagram in particular sends a \"user\" which can break your code in strange ways if it's overwritten\n      if (compiled[k]) {\n        compiled.extra || (compiled.extra = {});\n        compiled.extra[k] = extra[k];\n      } else {\n        compiled[k] = extra[k];\n      }\n    }\n    return compiled;\n  })\n  .getSession( function (req) {\n    return req.session;\n  })\n  .addToSession( function (sess, auth) {\n    var _auth = sess.auth || (sess.auth = {})\n      , mod = _auth[this.name] || (_auth[this.name] = {});\n    _auth.loggedIn = true;\n    _auth.userId || (_auth.userId = auth.user[this._userPkey]);\n    mod.user = auth.oauthUser;\n    mod.accessToken = auth.accessToken;\n    // this._super() ?\n  })\n  .sendResponse( function (res, data) {\n    var req = data.req;\n    var continueTo = req.query && req.query['state'];\n\n    if (continueTo) {\n      return this.redirect(res, continueTo);\n    }\n\n    var redirectTo = this._redirectPath;\n    if (!redirectTo)\n      throw new Error('You must configure a redirectPath');\n    this.redirect(res, redirectTo);\n  })\n\n  .authCallbackDidErr( function (req, res) {\n    return false;\n  });\n\noauth2.moreAuthQueryParams = {};\noauth2.moreAccessTokenParams = {};\noauth2.cloneOnSubmodule.push('moreAuthQueryParams', 'moreAccessTokenParams');\n\noauth2\n  .authPath('/oauth/authorize')\n  .accessTokenPath('/oauth/access_token')\n  .accessTokenHttpMethod('post')\n  .postAccessTokenParamsVia('query')\n  .handleAuthCallbackError( function (req, res, next) {\n    next(Error(\"You must configure handleAuthCallbackError in this module\"));\n  })\n\n// Add or over-write existing query params that\n// get tacked onto the oauth authorize url.\noauth2.authQueryParam = function (key, val) {\n  if (arguments.length === 1 && key.constructor == Object) {\n    for (var k in key) {\n      this.authQueryParam(k, key[k]);\n    }\n    return this;\n  }\n  if (val)\n    this.moreAuthQueryParams[key] = val;\n  return this;\n};\n\n// Add or over-write existing params that\n// get sent with the oauth access token request.\noauth2.accessTokenParam = function (key, val) {\n  if (arguments.length === 1 && key.constructor == Object) {\n    for (var k in key) {\n      this.accessTokenParam(k, key[k]);\n    }\n    return this;\n  }\n  if (val)\n    this.moreAccessTokenParams[key] = val;\n  return this;\n};\n\n/**\n * Where to redirect to after a failed or successful OAuth authorization\n */\noauth2.redirectPath = function (path) {\n  if (typeof path === 'function') {\n    var self = this;\n    // req here is the auth request, not the callback request\n    this.authQueryParam('state', function (req, res) {\n      return path.call(self, req, res);\n    });\n  } else {\n    this._redirectPath = path;\n    return this;\n  }\n};\n\n// removeConfigurable\n// removeStep\n// undefinedSteps -> []\n// How about module specific and more generic addToSession? Perhaps just do addToSession with null\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/everymodule.js":"var url = require('url');\nvar Step = require('../step');\nvar StepSequence = require('../stepSequence');\nvar RouteTriggeredSequence = require('../routeTriggeredSequence');\nvar clone = require('../utils').clone;\nvar Promise = require('../promise');\n\n/**\n * Instances of EveryModule is the root ancestor of all other modules used for\n * auth.\n */\nfunction EveryModule () {\n  this._stepSequences = {};\n\n  // _configurable maps parameter names to descriptions\n  // It is used for introspection with this.configurable()\n  this._configurable = {};\n\n  this.submodules = {};\n\n  // _steps maps step names to step objects\n  // A step object is { accepts: [...], promises: [...] }\n  this._steps = {}\n\n  this._middleware = {};\n\n  this\n    .configurable({\n        moduleTimeout: 'How long to wait per step before timing out and invoking any timeout callbacks'\n      , moduleErrback: 'THE error callback that is invoked any time an error occurs in the module; ' +\n          'defaults to passing the error to connect/express `next` callback'\n      , logoutRedirectPath: 'Where to redirect the app upon logging out'\n      , findUserById: 'function for fetching a user by his/her id -- used to assign to `req.user` - function ( [req], userId, callback) where function callback (err, user)'\n      , performRedirect: 'function for redirecting responses'\n      , userPkey: 'identifying property of the user; defaults to \"id\"'\n    })\n    .get('logoutPath')\n      .step('handleLogout')\n        .accepts('req res next')\n        .promises(null)\n    .logoutPath('/logout')\n    .handleLogout( function (req, res) {\n      req.logout();\n      this.redirect(res, this.logoutRedirectPath());\n    })\n    .logoutRedirectPath('/')\n    .userPkey('id');\n\n  this.performRedirect( function(res, location) {\n    res.writeHead(303, { 'Location': location });\n    res.end();\n  });\n\n  this.moduleTimeout(10000);\n  this.moduleErrback( function (err, seqValues) {\n    if (! (err instanceof Error)) {\n      console.log('Warning: Try to pass only Errors');\n      err = new Error(JSON.stringify(err));\n    }\n    var next = seqValues.next;\n    next(err);\n  });\n}\n\nEveryModule.prototype.name = 'everymodule';\n\nEveryModule.prototype.definit = function (fn) {\n  // Remove any prior `init` that was assigned directly to the object via\n  // definit and not assigned via prototypal inheritance\n  if (this.hasOwnProperty('init')) delete this.init;\n\n  var _super = this.init;\n  // since this.hasOwnProperty('init') is false\n\n  this.init = function init () {\n    this._super = _super;\n    fn.apply(this, arguments);\n    delete this._super;\n\n    // Do module compilation here, too\n  };\n  return this;\n};\n\nEveryModule.prototype.stepseq = function (name, description) {\n  this.configurable(name, description);\n  this._currSeq =\n    this._stepSequences[name] || (this._stepSequences[name] = new StepSequence(name, this));\n  return this;\n};\n\nEveryModule.prototype.configurable = function (arg, description) {\n  // Support function signature:\n  //   module.configurable()\n  // Return a listing of the module's configuration\n  if (!arguments.length) return this._configurable;\n\n  var property;\n  if (arg.constructor == Object) {\n    for (property in arg) {\n      description = arg[property];\n      this.configurable(property, description);\n    }\n    return this;\n  }\n\n  console.assert('string' === typeof arg);\n\n  property = arg;\n\n  // Support function signature:\n  //   module.configurable(paramName);\n  // Returns the configurable param description\n  if (arguments.length === 1 && this[property]) {\n    return this._configurable[property];\n  }\n\n  // Support function signature:\n  //     module.configurable('someParam', 'description');\n  this[property] = function (setTo) {\n    var k = '_' + property;\n    if (arguments.length) {\n      this[k] = setTo;\n      return this;\n    }\n    // TODO this.everyauth is not yet available here in some contexts\n    //      For example, when we set and try to access a scope in an auth module definition\n    //      but if you look in index, everyauth is not assigned to the module until after it is\n    //      required\n    if ('undefined' === typeof this[k]) {\n      var debugMsg = 'WARNING: You are trying to access the attribute/method configured by `' +\n                     property + '`, which you did not configure. Time to configure it.';\n      throw new Error(debugMsg);\n    }\n    return this[k];\n  };\n\n  this._configurable[property] = description || 'No Description';\n\n  // Add configurable to submodules that inherit from this supermodule\n  for (var name in this.submodules) {\n    this.submodules[name].configurable(arg, description);\n  }\n  return this;\n};\n\n/**\n * Convenience method for all you coffee-script lovers, e.g.,\n *\n * everyauth.dropbox.configure\n *   consumerKey:       conf.dropbox.consumerKey\n *   consumerSecret:    conf.dropbox.consumerSecret\n *   findOrCreateUser:  (sess, accessToken, accessSecret, dbMeta) -> users[dbMeta.uid] or= addUser('dropbox', dbMeta)\n *   redirectPath:      '/'\n */\nEveryModule.prototype.configure = function (conf) {\n  for (var k in conf) {\n    this[k](conf[k]);\n  }\n  return this;\n};\n\n// TODO Move `.step(name)` behind StepSequence.prototype\nEveryModule.prototype.step = function (name) {\n  var sequence = this._currSeq;\n\n  if (!sequence) {\n    throw new Error(\"You can only declare a step after declaring a route alias via `get(...)` or `post(...)`.\");\n  }\n\n  sequence.orderedStepNames.push(name);\n\n  var steps = this._steps;\n  this._currentStep =\n    steps[name] || (steps[name] = new Step(name, this));\n\n  // For configuring what the actual business\n  // logic is:\n  // fb.step('fetchOAuthUser') generates the method\n  // fb.fetchOAuthUser whose logic can be configured like\n  // fb.fetchOAuthUser( function (...) {\n  //   // Business logic goes here\n  // } );\n  this.configurable(name,\n    'STEP FN [' + name + '] function encapsulating the logic for the step `' + name + '`.');\n  return this;\n};\n\nEveryModule.prototype.accepts = function (input) {\n  this._currentStep.accepts = input && input.split(/\\s+/) || null;\n  return this;\n};\n\nEveryModule.prototype.promises = function (output) {\n  this._currentStep.promises = output && output.split(/\\s+/) || null;\n  return this;\n};\n\nEveryModule.prototype.description = function (desc) {\n  var step = this._currentStep;\n  step.description = desc;\n  if (desc) desc = 'STEP FN [' + step.name + '] - ' + desc;\n  this.configurable(step.name, desc);\n  return this;\n};\n\nEveryModule.prototype.stepTimeout = function (millis) {\n  this._currentStep.timeout = millis;\n  return this;\n};\n\nEveryModule.prototype.stepErrback = function (fn) {\n  this._currentStep.errback = fn;\n  return this;\n};\n\nEveryModule.prototype.canBreakTo = function (sequenceName) {\n  // TODO Implement this (like static typing)\n  //      unless `canBreakTo` only needed for\n  //      readability\n  return this;\n};\n\nEveryModule.prototype.cloneOnSubmodule = [\n  'cloneOnSubmodule'\n, '_configurable'\n];\n\n// Creates a new submodule using prototypal inheritance\nEveryModule.prototype.submodule = function (name) {\n  var self = this\n      // So that when we add configurables after\n      // to the supermodule after the submodule\n      // creation, we can propagate those configurables\n      // to the supermodule's submodules\n    , submodule = this.submodules[name] = Object.create(this, {\n          name: { value: name }\n        , submodules: { value: {} }\n        , _middleware: { value: {} }\n      });\n\n  this.cloneOnSubmodule.forEach( function (toClone) {\n    submodule[toClone] = clone(self[toClone]);\n  });\n\n  var seqs = this._stepSequences\n    , newSeqs = submodule._stepSequences = {};\n  for (var seqName in seqs) {\n    newSeqs[seqName] = seqs[seqName].clone(submodule);\n  }\n\n  var steps = this._steps\n    , newSteps = submodule._steps = {};\n  for (var stepName in steps) {\n    newSteps[stepName] = steps[stepName].clone(stepName, submodule);\n  }\n\n  return submodule;\n};\n\nEveryModule.prototype.validateSequences = function () {\n  var seqs = this._stepSequences;\n  for (var seqName in seqs) {\n    seqs[seqName].validateSteps();\n  }\n};\n\n// Decorates the app with the routes required of the module\nEveryModule.prototype.routeApp = function (router) {\n  if (this.init) this.init();\n  var routes = this._routes;\n  var methods = ['get', 'post'];\n  for (var method in routes) {\n    for (var routeAlias in routes[method]) {\n      var middleware = this._middleware[routeAlias];\n      if (middleware) continue;\n      var path = this[routeAlias]();\n      if (!path)\n        throw new Error('You have not defined a path for the route alias ' + routeAlias + '.');\n      var seq = routes[method][routeAlias];\n\n      // This kicks off a sequence of steps based on a route\n      // Creates a new chain of promises and exposes the leading promise\n      // to the incoming (req, res) pair from the route handler\n      router.route(method, path, seq.routeHandler.bind(seq));\n    }\n  }\n};\n\nEveryModule.prototype.Promise = function (values) {\n  return new Promise(this, values);\n};\n\n/**\n * Function signature:\n *   breakTo(sequenceName, arg1, arg2, ...);\n *\n * [arg1, arg2, ...] are the arguments passed to the `sequence.start(...)`\n * where sequence is the sequence with the name `sequenceName`\n */\nEveryModule.prototype.breakTo = function (sequenceName) {\n  // TODO Garbage collect the abandoned sequence\n  var seq = this._stepSequences[sequenceName];\n  if (!seq) {\n    throw new Error('You are trying to break to a sequence named `' + sequenceName + '`, but there is no sequence with that name in the auth module, `' + this.name + '`.');\n  }\n  var args = Array.prototype.slice.call(arguments, 1);\n  seq = seq.materialize();\n  seq.initialArgs = args;\n  throw seq;\n};\n\n\nEveryModule.prototype.redirect = function (req, location) {\n  this._performRedirect(req, location);\n};\n\nvar routeDescPrefix = {\n    get: 'ROUTE (GET)'\n  , post: 'ROUTE (POST)'\n};\n\n['get', 'post'].forEach( function (httpMethod) {\n  EveryModule.prototype[httpMethod] = function (alias, description) {\n    if (description)\n      description = routeDescPrefix[httpMethod.toLowerCase()] + ' - ' + description;\n    this.configurable(alias, description);\n    var name = httpMethod + ':' + alias;\n    this._currSeq =\n      this._stepSequences[name] || (this._stepSequences[name] = new RouteTriggeredSequence(name, this));\n    return this;\n  };\n});\n\nEveryModule.prototype.middleware = function (endpointAlias) {\n  if (this.init) this.init();\n  var middleware = this._middleware[endpointAlias];\n  if (middleware) return middleware;\n  var self = this;\n  return this._middleware[endpointAlias] = function (req, res, next) {\n    var stepSequence = self.route.get[endpointAlias];\n    stepSequence.routeHandler(req, res, next);\n  };\n};\n\n// Used to determine if we should validate the module's sequences and setup the\n// module's routes. If a module is strictly used as a parent or ancestor module\n// to define a shared interface for submodules, then, this should be false.\nObject.defineProperty(EveryModule.prototype, 'shouldSetup', { get: function () {\n  return ! Object.keys(this.submodules).length;\n}});\n\nObject.defineProperty(EveryModule.prototype, '_routes', { get: function () {\n  var seqs = this._stepSequences\n    , methods = ['get', 'post'];\n  return Object.keys(seqs).filter( function (seqName) {\n    return ~methods.indexOf(seqName.split(':')[0]);\n  }).reduce( function (_routes, routeName) {\n    var parts = routeName.split(':')\n      , method = parts[0]\n      , routeAlias = parts[1];\n    _routes[method] || (_routes[method] = {});\n    _routes[method][routeAlias] = seqs[routeName];\n    return _routes;\n  }, {});\n}});\n\nObject.defineProperty(EveryModule.prototype, 'route', {\n  get: function () { return this._routes; }\n});\n\nObject.defineProperty(EveryModule.prototype, 'routes', {get: function () {\n  var arr = []\n    , _routes = this._routes\n    , _descriptions = this._configurable;\n  for (var method in _routes) {\n    for (var alias in _routes[method]) {\n      method = method.toUpperCase();\n      arr.push(method + ' (' + alias + ') [' +\n        this[alias]() + ']' +\n        _descriptions[alias].replace(routeDescPrefix[method.toLowerCase()], ''));\n    }\n  }\n  return arr;\n}});\n\nmodule.exports = new EveryModule;\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/500px.js":"var oauthModule = require('./oauth');\n\nmodule.exports =\noauthModule.submodule('500px')\n  .apiHost('https://api.500px.com/v1')\n  .oauthHost('https://api.500px.com/v1')\n  .entryPath('/auth/500px')\n  .callbackPath('/auth/500px/callback')\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/users', accessToken, accessTokenSecret, function (err, data) {\n      if (err) { return p.fail(err); }\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    });\n    return p;\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/oauth.js":"var everyModule = require('./everymodule')\n  , OAuth = require('oauth').OAuth\n  , url = require('url')\n  , extractHostname = require('../utils').extractHostname;\n\nvar oauth = module.exports =\neveryModule.submodule('oauth')\n  .configurable({\n      apiHost: 'e.g., https://api.twitter.com'\n    , oauthHost: 'the host for the OAuth provider'\n    , requestTokenPath: \"the path on the OAuth provider's domain where we request the request token, e.g., /oauth/request_token\"\n    , accessTokenPath: \"the path on the OAuth provider's domain where we request the access token, e.g., /oauth/access_token\"\n    , authorizePath: 'the path on the OAuth provider where you direct a visitor to login, e.g., /oauth/authorize'\n    , sendCallbackWithAuthorize: 'whether you want oauth_callback=... as a query param send with your request to /oauth/authorize'\n    , consumerKey: 'the api key provided by the OAuth provider'\n    , consumerSecret: 'the api secret provided by the OAuth provider'\n    , myHostname: 'e.g., http://localhost:3000 . Notice no trailing slash'\n    , alwaysDetectHostname: 'does not cache myHostname once. Instead, re-detect it on every request. Good for multiple subdomain architectures'\n    , redirectPath: 'Where to redirect to after a failed or successful OAuth authorization'\n    , convertErr: '(DEPRECATED) a function (data) that extracts an error message from data arg, where `data` is what is returned from a failed OAuth request'\n    , authCallbackDidErr: 'Define the condition for the auth module determining if the auth callback url denotes a failure. Returns true/false.'\n  })\n  .definit( function () {\n    this.oauth = new OAuth(\n        this.oauthHost() + this.requestTokenPath()\n      , this.oauthHost() + this.accessTokenPath()\n      , this.consumerKey()\n      , this.consumerSecret()\n      , '1.0', null, 'HMAC-SHA1');\n  })\n\n  .get('entryPath',\n       'the link a user follows, whereupon you redirect them to the 3rd party OAuth provider dialog - e.g., \"/auth/twitter\"')\n    .step('getRequestToken')\n      .description('asks OAuth Provider for a request token')\n      .accepts('req res next')\n      .promises('token tokenSecret')\n    .step('storeRequestToken')\n      .description('stores the request token and secret in the session')\n      .accepts('req token tokenSecret')\n      .promises(null)\n    .step('redirectToProviderAuth')\n      .description('sends the user to authorization on the OAuth provider site')\n      .accepts('res token')\n      .promises(null)\n\n  .get('callbackPath',\n       'the callback path that the 3rd party OAuth provider redirects to after an OAuth authorization result - e.g., \"/auth/twitter/callback\"')\n    .step('extractTokenAndVerifier')\n      .description('extracts the request token and verifier from the url query')\n      .accepts('req res next')\n      .promises('requestToken verifier')\n      .canBreakTo('handleDuplicateCallbackRequest')\n      .canBreakTo('authCallbackErrorSteps')\n    .step('getSession')\n      .accepts('req')\n      .promises('session')\n    .step('rememberTokenSecret')\n      .description('retrieves the request token secret from the session')\n      .accepts('session')\n      .promises('requestTokenSecret')\n    .step('getAccessToken')\n      .description('requests an access token from the OAuth provider')\n      .accepts('requestToken requestTokenSecret verifier')\n      .promises('accessToken accessTokenSecret params')\n    .step('fetchOAuthUser')\n      .accepts('accessToken accessTokenSecret params')\n      .promises('oauthUser')\n    .step('assignOAuthUserToSession')\n      .accepts('oauthUser session')\n      .promises('session')\n    .step('findOrCreateUser')\n      .accepts('session accessToken accessTokenSecret oauthUser')\n      .promises('user')\n    .step('compileAuth')\n      .accepts('accessToken accessTokenSecret oauthUser user')\n      .promises('auth')\n    .step('addToSession')\n      .accepts('session auth')\n      .promises(null)\n    .step('sendResponse')\n      .accepts('res')\n      .promises(null)\n\n  .stepseq('handleDuplicateCallbackRequest',\n    'handles the case if you manually click the callback link on Twitter, but Twitter has already sent a redirect request to the callback path with the same token')\n    .step('waitForPriorRequestToWriteSession')\n      .accepts('req res next')\n      .promises(null)\n    .step('sendResponse')\n\n  .stepseq('authCallbackErrorSteps')\n      .step('handleAuthCallbackError',\n           'a request handler that intercepts a failed authorization message sent from the OAuth provider to your service. e.g., the request handler for \"/auth/twitter/callback?denied=blahblahblahblahblah\"')\n        .accepts('req res next')\n        .promises(null)\n\n  .getRequestToken( function (req, res, next) {\n\n    // Automatic hostname detection + assignment\n    if (!this._myHostname || this._alwaysDetectHostname) {\n      this.myHostname(extractHostname(req));\n    }\n\n    var p = this.Promise()\n      , params = {oauth_callback: this._myHostname + this._callbackPath}\n      , additionalParams = this.moreRequestTokenQueryParams\n      , param;\n\n    if (additionalParams) for (var k in additionalParams) {\n      param = additionalParams[k];\n      if ('function' === typeof param) {\n        // e.g., for facebook module, param could be\n        // function () {\n        //   return this._scope && this.scope();\n        // }\n        additionalParams[k] = // cache the function call\n          param = param.call(this);\n      }\n      if ('function' === typeof param) {\n        // this.scope() itself could be a function\n        // to allow for dynamic scope determination - e.g.,\n        // function (req, res) {\n        //   return req.session.onboardingPhase; // => \"email\"\n        // }\n        param = param.call(this, req, res);\n      }\n      params[k] = param;\n    }\n    this.oauth.getOAuthRequestToken(params, function (err, token, tokenSecret, params) {\n      if (err) {\n        return p.fail(err);\n      }\n      p.fulfill(token, tokenSecret);\n    });\n    return p;\n  })\n  .storeRequestToken( function (req, token, tokenSecret) {\n    var sess = req.session\n      , _auth = sess.auth || (sess.auth = {})\n      , _provider = _auth[this.name] || (_auth[this.name] = {});\n    _provider.token = token;\n    _provider.tokenSecret = tokenSecret;\n  })\n  .redirectToProviderAuth( function (res, token) {\n    // Note: Not all oauth modules need oauth_callback as a uri query parameter. As far as I know, only readability's\n    // module needs it as a uri query parameter. However, in cases such as twitter, it allows you to over-ride\n    // the callback url settings at dev.twitter.com from one place, your app code, rather than in two places -- i.e.,\n    // your app code + dev.twitter.com app settings.\n    var redirectTo = this._oauthHost + this._authorizePath + '?oauth_token=' + token;\n    if (this._sendCallbackWithAuthorize) {\n      redirectTo += '&oauth_callback=' + this._myHostname + this._callbackPath;\n    }\n    this.redirect(res, redirectTo);\n  })\n\n  // Steps for GET `callbackPath`\n  .extractTokenAndVerifier( function (req, res, next) {\n    if (this._authCallbackDidErr && this._authCallbackDidErr(req)) {\n      return this.breakTo('authCallbackErrorSteps', req, res);\n    }\n    var parsedUrl = url.parse(req.url, true)\n      , query = parsedUrl.query\n      , requestToken = query && query.oauth_token\n      , verifier = query && query.oauth_verifier\n\n      , sess = req.session\n      , promise\n      , _auth = sess.auth || (sess.auth = {})\n      , name = this.name\n      , mod = _auth[name] || (_auth[name] = {});\n    if ((name === 'twitter') && (mod.token === requestToken) && (mod.verifier === verifier)) {\n      return this.breakTo('handleDuplicateCallbackRequest', req, res);\n    }\n\n    promise = this.Promise();\n    mod.verifier = verifier;\n    sess.save( function (err) {\n      if (err) return promise.fail(err);\n      promise.fulfill(requestToken, verifier);\n    });\n    return promise;\n  })\n  .getSession( function(req) {\n    return req.session;\n  })\n  .rememberTokenSecret( function (sess) {\n    return sess && sess.auth && sess.auth[this.name] && sess.auth[this.name].tokenSecret;\n  })\n  .getAccessToken( function (reqToken, reqTokenSecret, verifier) {\n    var promise = this.Promise();\n    this.oauth.getOAuthAccessToken(reqToken, reqTokenSecret, verifier, function (err, accessToken, accessTokenSecret, params) {\n      if (err) return promise.fail(err);\n      promise.fulfill(accessToken, accessTokenSecret, params);\n    });\n    return promise;\n  })\n  .assignOAuthUserToSession( function (oauthUser, session) {\n    session.auth[this.name].user = oauthUser;\n    return session;\n  })\n  .compileAuth( function (accessToken, accessTokenSecret, oauthUser, user) {\n    return {\n        accessToken: accessToken\n      , accessTokenSecret: accessTokenSecret\n      , oauthUser: oauthUser\n      , user: user\n    };\n  })\n  .addToSession( function (sess, auth) {\n    var promise = this.Promise()\n      , _auth = sess.auth\n      , mod = _auth[this.name];\n    _auth.loggedIn = true;\n    _auth.userId || (_auth.userId = auth.user[this._userPkey]);\n    mod.user = auth.oauthUser;\n    mod.accessToken = auth.accessToken;\n    mod.accessTokenSecret = auth.accessTokenSecret;\n    // this._super() ?\n    sess.save( function (err) {\n      if (err) return promise.fail(err);\n      promise.fulfill();\n    });\n    return promise;\n  })\n  .sendResponse( function (res, data) {\n    var redirectTo = this.redirectPath();\n    if (!redirectTo)\n      throw new Error('You must configure a redirectPath');\n    this.redirect(res, redirectTo);\n  })\n  .waitForPriorRequestToWriteSession( function (req, res, next) {\n    var promise = this.Promise();\n    function check (self, sess, res, promise) {\n      if (sess.auth[self.name].accessToken) {\n        return promise.fulfill();\n      }\n\n      setTimeout(function () {\n        sess.reload( function (err) {\n          if (err) return promise.fail(err);\n          check(self, req.session, res, promise);\n        });\n      }, 100);\n    }\n    check(this, req.session, res, promise);\n    return promise;\n  });\n\n// Defaults inherited by submodules\noauth\n  .requestTokenPath('/oauth/request_token')\n  .authorizePath('/oauth/authorize')\n  .accessTokenPath('/oauth/access_token')\n  .handleAuthCallbackError( function (req, res, next) {\n    next(new Error(\"You must configure handleAuthCallbackError in this module\"));\n  })\n  .sendCallbackWithAuthorize(true);\n\noauth.moreRequestTokenQueryParams = {};\noauth.cloneOnSubmodule.push('moreRequestTokenQueryParams');\n\n// Add or over-write existing query params that\n// get tacked onto the oauth authorize url.\noauth.requestTokenQueryParam = function (key, val) {\n  if (arguments.length === 1 && key.constructor == Object) {\n    for (var k in key) {\n      this.requestTokenQueryParam(k, key[k]);\n    }\n    return this;\n  }\n  if (val)\n    this.moreRequestTokenQueryParams[key] = val;\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/angellist.js":"var oauthModule = require('./oauth2');\n\nmodule.exports =\noauthModule.submodule('angellist')\n  .configurable({\n      scope: 'specify types of access: (no scope), user, public_repo, repo, gist'\n  })\n\n  .oauthHost('https://angel.co')\n  .apiHost('https://api.angel.co/1')\n\n  .authPath('/api/oauth/authorize')\n  .authQueryParam('response_type', 'code')\n\n  .accessTokenPath('/api/oauth/token')\n  .accessTokenParam('grant_type', 'authorization_code')\n\n  .entryPath('/auth/angellist')\n  .callbackPath('/auth/angellist/callback')\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/me', accessToken, function (err, data) {\n      if (err) return p.fail(err);\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    })\n    return p;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var angellistResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          angellistResponse.statusCode\n        , angellistResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/azureacs.js":"var everyModule = require('./everymodule')\n  , url = require('url')\n  , querystring = require('querystring')\n  , Swt = require('node-swt')\n  , WsFederation = require('node-wsfederation')\n  , openId = require('openid')\n  , extractHostname = require('../utils').extractHostname;\n\nvar azureacs = module.exports = \neveryModule.submodule('azureacs')\n  .definit( function () {\n    this.wsfederation = new WsFederation(this.realm(), this.homeRealm(), this.identityProviderUrl());\n  })\n  .configurable({\n      identityProviderUrl : 'the federation endpoint at the identity provider'\n      , signingKey   : 'a 256-bit symmetric key for the namespace'\n      , realm       : 'the relying party application identifier, e.g., http://myapp.cloudapp.net'\n      , redirectPath : 'the path to redirect once the user is authenticated'\n      , tokenFormat  : 'the format used to parse the token'\n      , homeRealm          : 'the indentity provider'\n      , authCallbackDidErr : 'Define the condition for the auth module determining if the auth callback url denotes a failure. Returns true/false.'\n  })\n\n  // Declares a GET route that is aliased\n  // as 'entryPath'. The handler for this route\n  // triggers the series of steps that you see\n  // indented below it.\n  .get('entryPath', \n       'the link a user follows, whereupon you redirect them to ACS url- e.g., \"/auth/facebook\"')          \n    .step('redirectToIdentityProviderSelector')\n      .accepts('req res next')\n      .promises(null)\n\n  .post('callbackPath',\n       'the callback path that the ACS redirects to after an authorization result - e.g., \"/auth/facebook/callback\"')\n    .step('getToken')\n      .description('retrieves a verifier code from the url query')\n      .accepts('req res next')\n      .promises('token')\n      .canBreakTo('notValidTokenCallbackErrorSteps')\n      .canBreakTo('authCallbackErrorSteps')\n    .step('parseToken')\n      .description('retrieves a verifier code from the url query')\n      .accepts('token')\n      .promises('claims')\n      .canBreakTo('notValidTokenCallbackErrorSteps')\n    .step('fetchUser')\n      .accepts('claims')\n      .promises('acsUser')\n    .step('getSession')\n      .accepts('req')\n      .promises('session')\n    .step('findOrCreateUser')\n      .accepts('session acsUser')\n      .promises('user')\n    .step('addToSession')\n      .accepts('session acsUser token')\n      .promises(null)\n    .step('sendResponse')\n      .accepts('res')\n      .promises(null)\n\n  .stepseq('authCallbackErrorSteps')\n      .step('handleAuthCallbackError',\n           'a request handler that intercepts a failed authorization message sent from the ACS provider to your service. e.g., the request handler for \"/auth/facebook/callback?error_reason=user_denied&error=access_denied&error_description=The+user+denied+your+request.\"')\n        .accepts('req res next')\n        .promises(null)\n\n  .stepseq('protocolNotImplementedErrorSteps')\n      .step('handleProtocolNotImplementedError',\n           'the protocol specified is not implemented yet.')\n        .accepts('tokenFormat')\n        .promises(null)\n\n  .stepseq('notValidTokenCallbackErrorSteps')\n      .step('handleNotValidTokenCallbackError',\n           'the token is not valid\"')\n        .accepts('token')\n        .promises(null)\n\n  .redirectToIdentityProviderSelector( function (req, res) {\n    var identityProviderSelectorUri = this.wsfederation.getRequestSecurityTokenUrl();\n    this.redirect(res, identityProviderSelectorUri);\n  })\n\n  .getToken( function (req, res) {\n    var token = this.wsfederation.extractToken(res);\n\n    if (this.tokenFormat() === 'swt') {\n      var str = token['wsse:BinarySecurityToken']['#'];\n      var result = new Buffer(str, 'base64').toString('ascii'); \n    }\n    else {\n      return this.breakTo('protocolNotImplementedErrorSteps', this.tokenFormat());\n    }\n\n    if (this._authCallbackDidErr(req)) {\n      return this.breakTo('authCallbackErrorSteps', req, res);\n    }\n\n    return result;\n  })\n\n  .parseToken( function (token) {\n    if (this.tokenFormat() === 'swt') {\n      var swt = new Swt(token);\n      if (!swt.isValid(token, this.realm(), this.signingKey())) {\n        return this.breakTo('notValidTokenCallbackErrorSteps', token);\n      }\n      return swt.claims;\n    }\n\n    return this.breakTo('protocolNotImplementedErrorSteps', this.tokenFormat());\n  })\n\n  .getSession( function (req) {\n    return req.session;\n  })\n\n  .fetchUser( function (claims) {\n     var user = {};\n     user['azureacs'] = claims;\n     return user;\n  })\n\n  .addToSession( function (sess, acsUser, token) {\n    var _auth = sess.auth || (sess.auth = {})\n      , mod = _auth[this.name] || (_auth[this.name] = {});\n    _auth.loggedIn = true;\n    _auth.userId || (_auth.userId = acsUser.id);\n    mod.user = acsUser;\n    mod.accessToken = token;\n  })\n\n  .sendResponse( function (res) {\n    var redirectTo = this.redirectPath();\n    if (!redirectTo)\n      throw new Error('You must configure a redirectPath');\n    this.redirect(res, redirectTo);\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n\n .handleNotValidTokenCallbackError( function (token) {\n    throw new Error(\"The token received is NOT valid\");\n  })\n\n  .handleAuthCallbackError( function (req, res) {\n    throw new Error(\"Authorization Error\");\n  })\n\n  .handleProtocolNotImplementedError( function (tokenFormat) {\n    throw new Error(\"The protocol specified is not implemented. Token format:\" +tokenFormat);    \n  })\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/box2.js":"var oauthModule = require('./oauth2'),\n    url = require('url'),\n    request = require('request');\n\nvar box2 = module.exports =\noauthModule.submodule('box2')\n\n  .oauthHost('https://api.box.com')\n  .apiHost('https://api.box.com')\n\n  .authPath('/oauth2/authorize')\n  .authQueryParam('response_type', 'code')\n\n  .accessTokenPath('/oauth2/token')\n  .accessTokenParam('grant_type', 'authorization_code')\n  .accessTokenHttpMethod('post')\n  .postAccessTokenParamsVia('data')\n\n  .entryPath('/auth/box2')\n  .callbackPath('/auth/box2/callback')\n\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true),\n        errorDesc = parsedUrl.query.error + \"; \" + parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n\n    request.get({\n      url: this.apiHost() + '/2.0/users/me',\n      headers: {'Authorization': 'Bearer ' + accessToken}\n    }, function(err, res, body){\n      if(err) {\n        return p.fail(err);\n      } else {\n        if(parseInt(res.statusCode/100,10) !==2){\n          return p.fail({extra:{data:body, res: res}});\n        }\n        p.fulfill(JSON.parse(body));\n      }\n    });\n\n    return p;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var box2Response = err.extra.res,\n          serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          box2Response.statusCode,\n          box2Response.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/box.js":"var oauthModule = require('./oauth2')\n    , request = require('request');\n\nvar box = module.exports =\n    oauthModule.submodule('box')\n        .configurable({\n            scope: 'specify types of access: (no scope), user, public_repo, repo, gist'\n        })\n\n        .oauthHost('https://www.box.com')\n        .apiHost('https://api.box.com/2.0')\n\n        .authPath('/api/oauth2/authorize')\n        .accessTokenPath('/api/oauth2/token')\n        .postAccessTokenParamsVia('data')\n\n        .entryPath('/auth/box')\n        .callbackPath('/auth/box/callback')\n\n        .authQueryParam('response_type', 'code')\n        .accessTokenParam('grant_type', 'authorization_code')\n\n        .fetchOAuthUser( function (accessToken) {\n            var promise = this.Promise();\n            request.get({\n                url: this.apiHost() + '/users/me'\n                , headers: { Authorization: \"Bearer \" + accessToken }\n            }, function (err, res, body) {\n                if (err) {\n                    err.extra = {res: res, data: body};\n                    return promise.fail(err);\n                }\n                if (parseInt(res.statusCode/100, 10) !== 2) {\n                    return promise.fail({extra: {data: body, res: res}});\n                }\n                var oauthUser = JSON.parse(body);\n                return promise.fulfill(oauthUser);\n            });\n            return promise;\n        })\n        .moduleErrback( function (err, seqValues) {\n            if (err instanceof Error) {\n                var next = seqValues.next;\n                return next(err);\n            } else if (err.extra) {\n                var ghResponse = err.extra.res\n                    , serverResponse = seqValues.res;\n                serverResponse.writeHead(\n                    ghResponse.statusCode\n                    , ghResponse.headers);\n                serverResponse.end(err.extra.data);\n            } else if (err.statusCode) {\n                var serverResponse = seqValues.res;\n                serverResponse.writeHead(err.statusCode);\n                serverResponse.end(err.data);\n            } else {\n                console.error(err);\n                throw new Error('Unsupported error type');\n            }\n        });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/dropbox.js":"var oauthModule = require('./oauth'),\n    url = require('url');\n\nvar dropbox = module.exports =\noauthModule.submodule('dropbox')\n  .apiHost('https://api.dropbox.com/1')\n  .oauthHost('https://www.dropbox.com/1')\n  .entryPath('/auth/dropbox')\n  .callbackPath('/auth/dropbox/callback')\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.not_approved;\n  })\n\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true),\n        errorDesc = parsedUrl.query.error + \"; \" + parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/account/info', accessToken, accessTokenSecret, function (err, data) {\n      if (err) return p.fail(err);\n      var oauthUser = JSON.parse(data);\n      oauthUser.id = oauthUser.uid;\n      p.fulfill(oauthUser);\n    });\n    return p;\n  })\n\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var dropboxResponse = err.extra.res,\n          serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          dropboxResponse.statusCode,\n          dropboxResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/dwolla.js":"var oauthModule = require('./oauth2')\n  , request = require('request');\n\nvar dwolla = module.exports =\noauthModule.submodule('dwolla')\n  .configurable({\n    scope: 'specify types of access: accountinfofull|request|contacts|balance|send|transactions'\n  })\n\n  .oauthHost('https://www.dwolla.com')\n  .apiHost('https://www.dwolla.com/oauth/rest')\n\n  .authPath('/oauth/v2/authenticate')\n  .accessTokenPath('/oauth/v2/token')\n  .accessTokenParam('grant_type', 'authorization_code')\n\n  .entryPath('/auth/dwolla')\n  .callbackPath('/auth/dwolla/callback')\n\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .authQueryParam('response_type', 'code')\n\n  .fetchOAuthUser( function (accessToken) {\n    var promise = this.Promise();\n    request.get({\n        url: this.apiHost() + '/users'\n      , qs: { oauth_token: accessToken, alt: 'json' }\n    }, function (err, res, body) {\n      if (err) {\n        err.extra = {res: res, data: body};\n        return promise.fail(err);\n      }\n      if (parseInt(res.statusCode/100, 10) !== 2) {\n        return promise.fail({extra: {data: body, res: res}});\n      }\n      var oauthUser = JSON.parse(body).Response;\n      return promise.fulfill(oauthUser);\n    });\n\n    return promise;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var dwollaResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          dwollaResponse.statusCode\n        , dwollaResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/evernote.js":"var oauthModule = require('./oauth')\n  , url = require('url');\n\nvar evernote = module.exports =\noauthModule.submodule('evernote')\n  .oauthHost('https://www.evernote.com')\n  .entryPath('/auth/evernote')\n  .callbackPath('/auth/evernote/callback')\n  .authorizePath('/OAuth.action')\n  .requestTokenPath('/oauth')\n  .accessTokenPath('/oauth')\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var oauthUser = {\n      shardId: params.edam_shard\n    , userId: parseInt(params.edam_userId, 10)\n    };\n    accessToken.split(':').forEach(function(item) {\n      item = item.split('=');\n      if (item[0] === 'A') {\n        oauthUser['username'] = item[1];\n      }\n    });\n    return oauthUser;\n  });","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/facebook.js":"var oauthModule = require('./oauth2')\n  , url = require('url');\n\nvar fb = module.exports =\noauthModule.submodule('facebook')\n  .configurable({\n      scope: 'specify types of access: See http://developers.facebook.com/docs/authentication/permissions/',\n      fields: 'specify returned fields: See http:/developers.facebook.com/docs/reference/api/user/'\n  })\n\n  .apiHost('https://graph.facebook.com/v2.0')\n  .oauthHost('https://graph.facebook.com/v2.0')\n\n  .authPath('https://www.facebook.com/v2.0/dialog/oauth')\n\n  .entryPath('/auth/facebook')\n  .callbackPath('/auth/facebook/callback')\n\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true)\n      , errorDesc = parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n    var fieldsQuery = \"\";\n    if (this._fields && this._fields.length > 0){\n        fieldsQuery = \"?fields=\" + this.fields();\n    }\n    this.oauth.get(this.apiHost() + '/me' + fieldsQuery, accessToken, function (err, data) {\n      if (err) return p.fail(err);\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    })\n    return p;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var facebookResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          facebookResponse.statusCode\n        , facebookResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n\nfb.mobile = function (isMobile) {\n  if (isMobile) {\n    this.authPath('https://m.facebook.com/v2.0/dialog/oauth');\n  }\n  return this;\n};\n\nfb.popup = function (isPopup) {\n  if (isPopup) {\n    this.authQueryParam('display', 'popup');\n  }\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/foursquare.js":"var oauthModule = require('./oauth2')\n  , request = require('request');\n\nvar foursquare = module.exports =\noauthModule.submodule('foursquare')\n  .apiHost('https://api.foursquare.com/v2')\n  .oauthHost('https://foursquare.com')\n\n  .authPath('/oauth2/authenticate')\n  .accessTokenPath('/oauth2/access_token')\n\n  .entryPath('/auth/foursquare')\n  .callbackPath('/auth/foursquare/callback')\n\n  .authQueryParam('response_type', 'code')\n\n  .accessTokenHttpMethod('get')\n  .accessTokenParam('grant_type', 'authorization_code')\n\n  .fetchOAuthUser( function (accessToken) {\n    var promise = this.Promise()\n      , userUrl = this.apiHost() + '/users/self'\n      , queryParams = { oauth_token: accessToken, v: '20131201' }\n    request.get({ url: userUrl, qs: queryParams}, function (err, res, body) {\n      if (err) {\n        err.extra = {res: res, data: body};\n        return promise.fail(err);\n      }\n      if (parseInt(res.statusCode/100, 10) !== 2) {\n        return promise.fail({extra: {data: body, res: res}});\n      }\n      var oauthUser = JSON.parse(body).response.user;\n      return promise.fulfill(oauthUser);\n    });\n    return promise;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var foursquareResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          foursquareResponse.statusCode\n        , foursquareResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/github.js":"var oauthModule = require('./oauth2'),\n    url = require('url');\n\nvar github = module.exports =\noauthModule.submodule('github')\n  .configurable({\n      scope: 'specify types of access: (no scope), user, public_repo, repo, gist'\n  })\n\n  .oauthHost('https://github.com')\n  .apiHost('https://api.github.com')\n\n  .customHeaders({'User-Agent': 'everyauth-github'})\n\n  .authPath('/login/oauth/authorize')\n  .accessTokenPath('/login/oauth/access_token')\n\n  .entryPath('/auth/github')\n  .callbackPath('/auth/github/callback')\n\n  .customHeaders({'User-Agent': 'everyauth-github'})\n\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true),\n        errorDesc = parsedUrl.query.error + \"; \" + parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/user', accessToken, function (err, data) {\n      if (err) return p.fail(err);\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    });\n    return p;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var ghResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          ghResponse.statusCode\n        , ghResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/google1.js":"var oauthModule = require('./oauth')\n  , extractHostname = require('../utils').extractHostname;\n\nvar google = module.exports =\noauthModule.submodule('google1')\n  .configurable({\n      scope: \"URL identifying the Google service to be accessed. See the documentation for the API you'd like to use for what scope to specify. To specify more than one scope, list each one separated with a space.\"\n  })\n  .apiHost('https://www.google.com')\n  .oauthHost('https://www.google.com')\n\n  .entryPath('/auth/google1')\n  .callbackPath('/auth/google1/callback')\n\n  .requestTokenPath('/accounts/OAuthGetRequestToken')\n  .authorizePath('/accounts/OAuthAuthorizeToken')\n  .accessTokenPath('/accounts/OAuthGetAccessToken')\n\n  .requestTokenQueryParam({\n      access_type: 'offline'\n    , approval_prompt: 'force'\n    , scope: function () {\n        return this._scope && this.scope();\n      }\n  })\n\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise()\n      , userUrl = 'https://www.google.com/m8/feeds/contacts/default/full?alt=json';\n    this.oauth.get(userUrl, accessToken, accessTokenSecret, function (err, data, res) {\n      if (err) {\n        err.extra = {data: data, res: res};\n        return promise.fail(err);\n      }\n      var oauthUser = JSON.parse(data)\n        , user = { gmail: oauthUser.feed.id.$t };\n      promise.fulfill(user);\n    });\n    return promise;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var twitterResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          twitterResponse.statusCode\n        , twitterResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/googlehybrid.js":"var openidModule = require('./openid')\n  , OAuth = require('oauth').OAuth\n  , oid = require('openid')\n  , extractHostname = require('../utils').extractHostname;\n\nvar googlehybrid = module.exports =\nopenidModule.submodule('googlehybrid')\n  .configurable({\n       scope: 'array of desired google api scopes'\n     , consumerKey: 'Consumer Key'\n     , consumerSecret: 'Consumer Secret'\n  })\n  .definit( function () {\n    this.relyingParty =\n      new oid.RelyingParty(this._myHostname + this._callbackPath, null, false, false, [\n          new oid.AttributeExchange({\n              'http://axschema.org/contact/email': 'required'\n            , 'http://axschema.org/namePerson/first': 'required'\n            , 'http://axschema.org/namePerson/last': 'required'\n          })\n        , new oid.OAuthHybrid({\n              consumerKey: this._consumerKey\n            , scope: this._scope.join(' ')\n          })\n      ]);\n\n    this.oauth = new OAuth(\n        'https://www.google.com/accounts/OAuthGetRequestToken'\n      , 'https://www.google.com/accounts/OAuthGetAccessToken'\n      , this._consumerKey\n      , this._consumerSecret\n      , \"1.0\",  null, \"HMAC-SHA1\");\n  })\n  .verifyAttributes(function (req,res) {\n    var p = this.Promise()\n        oauth = this.oauth;\n    this.relyingParty.verifyAssertion(req, function (err, userAttributes) {\n      if(err) return p.fail(err);\n      oauth.getOAuthAccessToken(userAttributes['request_token'], undefined, function (err, oauthAccessToken, oauthAccessTokenSecret) {\n        if (err) return p.fail(err);\n        userAttributes['access_token'] = oauthAccessToken;\n        userAttributes['access_token_secret'] = oauthAccessTokenSecret;\n        p.fulfill(userAttributes)\n      });\n    });\n    return p;\n  })\n  .sendToAuthenticationUri(function (req, res) {\n\n    // Automatic hostname detection + assignment\n    if (!this._myHostname || this._alwaysDetectHostname) {\n      this.myHostname(extractHostname(req));\n    }\n    \n    var self = this;\n    \n    this.relyingParty.authenticate('http://www.google.com/accounts/o8/id', false, function (err,authenticationUrl){\n      if(err) return p.fail(err);\n      self.redirect(res, authenticationUrl);\n    });\n  }) \n  .entryPath('/auth/googlehybrid')\n  .callbackPath('/auth/googlehybrid/callback');\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/openid.js":"var everyModule = require('./everymodule')\n  , oid = require('openid')\n  , url = require('url')\n  , extractHostname = require('../utils').extractHostname;\n\nvar openid = module.exports =\neveryModule.submodule('openid')\n  .configurable({\n      simpleRegistration: 'e.g., {\"nickname\" : true}'\n    , attributeExchange: 'eg {\"http://axschema.org/contact/email\": \"required\"}'\n    , myHostname: 'e.g., http://localhost:3000 . Notice no trailing slash'\n    , alwaysDetectHostname: 'does not cache myHostname once. Instead, re-detect it on every request. Good for multiple subdomain architectures'\n    , redirectPath : 'The path to redirect To' \n    , openidURLField : 'The post field to use for open id'\n  })\n  .definit( function () {\n    this.relyingParty = new oid.RelyingParty(this.myHostname() + this.callbackPath(), null, false, false, [\n        new oid.UserInterface()\n      , new oid.SimpleRegistration(this.simpleRegistration())\n      , new oid.AttributeExchange(this.attributeExchange())\n    ]);\n  })\n  .get('entryPath',\n  'the link a user follows, whereupon you kick off the OpenId auth process - e.g., \"/auth/openid\"')\n    .step('sendToAuthenticationUri')\n      .description('sends the user to the providers openid authUrl')\n      .accepts('req res next')\n      .promises(null)\n  .get('callbackPath',\n  'the callback path that the 3rd party Openid provider redirects to after an authorization result - e.g., \"/auth/openid/callback\"')\n    .step('verifyAttributes')\n      .description('verifies the return attributes')\n      .accepts('req res next')\n      .promises('userAttributes')\n    .step('getSession')\n      .accepts('req')\n      .promises('session')\n    .step('findOrCreateUser')\n      .accepts('session userAttributes')\n      .promises('user')\n    .step('addToSession')\n      .accepts('session user')\n      .promises(null)\n    .step('sendResponse')\n      .accepts('res')\n      .promises(null)\n  .sendToAuthenticationUri(function(req,res) {\n\n    // Automatic hostname detection + assignment\n    if (!this._myHostname || this._alwaysDetectHostname) {\n      this.myHostname(extractHostname(req));\n    }\n    \n    var p = this.Promise();\n\n    this.relyingParty.authenticate(req.query[this.openidURLField()], false, (function(err,authenticationUrl){\n      if(err) return p.fail(err);\n      this.redirect(res, authenticationUrl);\n    }).bind(this));\n\n    p.fulfill();\n    return p;\n  })\n  .getSession( function(req) {\n    return req.session;\n  })\n  .verifyAttributes(function(req,res) {\n    var p = this.Promise();\n    this.relyingParty.verifyAssertion(req, function (err,userAttributes) {\n      if(err) return p.fail(err);\n      p.fulfill(userAttributes)\n    });\n    return p;\n  })\n  .addToSession( function (sess, user) {\n    var _auth = sess.auth || (sess.auth = {})\n      , mod = _auth[this.name] || (_auth[this.name] = {});\n    _auth.loggedIn = true;\n    _auth.userId = user[this._userPkey];\n    mod.user = user;\n  })\n  .sendResponse( function (res) {\n    var redirectTo = this.redirectPath();\n    if (!redirectTo)\n      throw new Error('You must configure a redirectPath');\n    this.redirect(res, redirectTo);\n  })\n  .redirectPath('/')\n  .entryPath('/auth/openid')\n  .callbackPath('/auth/openid/callback')\n  .simpleRegistration({\n      \"nickname\" : true\n    , \"email\"    : true\n    , \"fullname\" : true\n    , \"dob\"      : true\n    , \"gender\"   : true\n    , \"postcode\" : true\n    , \"country\"  : true\n    , \"language\" : true\n    , \"timezone\" : true\n  })\n  .attributeExchange({\n      \"http://axschema.org/contact/email\"       : \"required\"\n    , \"http://axschema.org/namePerson/friendly\" : \"required\"\n    , \"http://axschema.org/namePerson\"          : \"required\"\n    , \"http://axschema.org/namePerson/first\"    : \"required\"\n    , \"http://axschema.org/contact/country/home\": \"required\"\n    , \"http://axschema.org/media/image/default\" : \"required\"\n    , \"http://axschema.org/x/media/signature\"   : \"required\"\n  })\n  .openidURLField('openid_identifier');\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/google.js":"var oauthModule = require('./oauth2')\n  , url = require('url')\n  , request = require('request');\n\nvar google = module.exports =\noauthModule.submodule('google')\n  .configurable({\n      scope: \"URL identifying the Google service to be accessed. See the documentation for the API you'd like to use for what scope to specify. To specify more than one scope, list each one separated with a space.\"\n  })\n\n  .oauthHost('https://accounts.google.com')\n  .apiHost('https://www.google.com/m8/feeds')\n\n  .authPath('/o/oauth2/auth')\n  .authQueryParam('response_type', 'code')\n\n  .accessTokenPath('/o/oauth2/token')\n  .accessTokenParam('grant_type', 'authorization_code')\n  .accessTokenHttpMethod('post')\n  .postAccessTokenParamsVia('data')\n\n  .entryPath('/auth/google')\n  .callbackPath('/auth/google/callback')\n\n  .authQueryParam({\n      access_type: 'offline'\n    , approval_prompt: 'force'\n    , scope: function () {\n        return this._scope && this.scope();\n      }\n  })\n\n  .addToSession( function (sess, auth) {\n    this._super(sess, auth);\n    if (auth.refresh_token) {\n      sess.auth[this.name].refreshToken = auth.refresh_token;\n      sess.auth[this.name].expiresInSeconds = parseInt(auth.expires_in, 10);\n    }\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true)\n      , errorDesc = parsedUrl.query.error + \"; \" + parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var googleResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          googleResponse.statusCode\n        , googleResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken) {\n    var promise = this.Promise()\n      , userUrl = 'https://www.googleapis.com/oauth2/v1/userinfo'\n      , queryParams = { access_token: accessToken, alt: 'json' };\n    request.get({\n        url: userUrl\n      , qs: queryParams\n    }, function (err, res, body) {\n      if (err) return promise.fail(err);\n      if (parseInt(res.statusCode/100, 10) !== 2) {\n        return promise.fail({extra: {data: body, res: res}});\n      }\n      promise.fulfill(JSON.parse(body));\n    });\n    return promise;\n  });\n\n/**\n * @param {Object} params in an object that includes the keys:\n * - refreshToken: The refresh token returned from the authorization code\n *   exchange\n * - clientId: The client_id obtained during application registration\n * - clientSecret: The client secret obtained during the application registration\n * @param {Function} cb\n */\ngoogle.refreshToken = function (params, cb) {\n  request.post('https://accounts.google.com/o/oauth2/token', {\n    form: {\n      refresh_token: params.refreshToken\n    , client_id: params.clientId\n    , client_secret: params.clientSecret\n    , grant_type: 'refresh_token'\n    }\n  }, function (err, res, body) {\n    // `body` should look like:\n    // {\n    //   \"access_token\":\"1/fFBGRNJru1FQd44AzqT3Zg\",\n    //   \"expires_in\":3920,\n    //   \"token_type\":\"Bearer\",\n    // }\n    if (err) return cb(err);\n    if (parseInt(res.statusCode / 100, 10) !== 2) {\n      cb(null, {}, res);\n    } else {\n      body = JSON.parse(body);\n      cb(null, {\n        accessToken: body.access_token\n      , expiresIn: body.expires_in\n      , idToken: body.id_token\n      }, res);\n    }\n  });\n  return this;\n}\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/gowalla.js":"var oauthModule = require('./oauth2')\n  , request = require('request');\n\nvar gowalla = module.exports =\noauthModule.submodule('gowalla')\n  .apiHost('https://api.gowalla.com')\n  .oauthHost('https://gowalla.com')\n\n  .authPath('/api/oauth/new')\n  .accessTokenPath('https://api.gowalla.com/api/oauth/token')\n\n  .entryPath('/auth/gowalla')\n  .callbackPath('/auth/gowalla/callback')\n\n  .accessTokenHttpMethod('post')\n  .postAccessTokenParamsVia('data')\n  .accessTokenParam('grant_type', 'authorization_code')\n\n  .fetchOAuthUser( function (accessToken) {\n    var promise = this.Promise();\n    request.get({\n        url: this._apiHost + '/users/me'\n      , qs: { oauth_token: accessToken }\n      , headers: {\n            \"X-Gowalla-API-Key\": this.appId()\n          , \"Accept\": \"application/json\"\n        }\n    }, function (err, res, body) {\n      if (err) {\n        err.extra = {res: res, data: body};\n        return promise.fail(err);\n      }\n      if (parseInt(res.statusCode/100, 10) !== 2) {\n        return promise.fail({extra: {data: body, res: res}});\n      }\n      var oauthUser = JSON.parse(body);\n      return promise.fulfill(oauthUser);\n    });\n\n    return promise;\n  })\n\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var gowallaResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          gowallaResponse.statusCode\n        , gowallaResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/guest.js":"var everyModule = require('./everymodule');\n\nvar guestModule = module.exports =\neveryModule.submodule('guest')\n  .configurable({\n    redirectPath: 'Where to redirect to after a failed or successful OAuth authorization'\n  })\n  .get('entryPath',\n    'the link a user follows to initiate authorization')\n    .step('getGuestId')\n      .description('Retrieves guest id - if any - from the request')\n      .accepts('req res')\n      .promises('guestId')\n    .step('createOrVerifyGuest')\n      .description('Creates a new guest account or validates an existing one')\n      .accepts('guestId req')\n      .promises('userOrErrors')\n    .step('interpretUserOrErrors')\n      .description('Pipes the output of the previous step into either the `user` or `errors`')\n      .accepts('userOrErrors')\n      .promises('user errors')\n    .step('getSession')\n      .description('Retrieves the session of the incoming request and returns in')\n      .accepts('req')\n      .promises('session')\n    .step('addToSession')\n      .description('Adds the user to the session')\n      .accepts('session user errors')\n      .promises(null)\n    .step('maybeLoginSucceed')\n      .description('Execute a HTTP response for a successful login')\n      .accepts('res user')\n      .promises(null)\n    .step('maybeLoginFail')\n      .description('Execute a HTTP response for a failed login')\n      .accepts('req res errors')\n      .promises(null)\n  .entryPath('/auth/guest')\n  .getGuestId(function(req, res) {\n    return (req.query && req.query.login) || null;\n  })\n  .getSession( function(req) {\n    return req.session;\n  })\n  .addToSession( function (sess, user, errors) {\n    var _auth = sess.auth || {};\n    if (!sess.auth) {\n      sess.auth = _auth;\n    }\n    if (user) {\n      _auth.userId = user.id;\n    }\n    _auth.loggedIn = !!user;\n  })\n  .interpretUserOrErrors( function (userOrErrors) {\n    if (Array.isArray(userOrErrors)) {\n      return [null, userOrErrors]; // We have an array of errors\n    } else {\n      return [userOrErrors, []]; // We have a user\n    }\n  })\n  .maybeLoginSucceed( function (res, user) {\n    if (user) {\n      this.redirect(res, this.redirectPath());\n    }\n  })\n  .maybeLoginFail( function (req, res, errors, login) {\n    if (errors && errors.length) {\n      if (res.render) {\n        res.render(__dirname + '/../views/auth-fail.jade', {\n          errorDescription: errors[0]\n        });\n      } else {\n        throw new Error(\"You must configure maybeLoginFail if you are not using express\");\n      }\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/instagram.js":"var oauthModule = require('./oauth2')\n  , querystring= require('querystring');\n\nvar instagram = module.exports =\noauthModule.submodule('instagram')\n  .configurable({\n      display: 'set to \"touch\" if you want users to see a mobile optimized version of the auth page'\n    , scope: 'specify types of access (space separated if > 1): basic (default), comments, relationships, likes'\n  })\n\n  .oauthHost('https://api.instagram.com')\n  .apiHost('https://api.instagram.com/v1')\n\n  .entryPath('/auth/instagram')\n  .callbackPath('/auth/instagram/callback')\n\n  .authQueryParam('response_type', 'code')\n  .authQueryParam('display', function () {\n    return this._display && this.display();\n  })\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .accessTokenParam('grant_type', 'authorization_code')\n  .postAccessTokenParamsVia('data')\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/users/self', accessToken, function (err, data) {\n      if (err) return p.fail(err.error_message);\n      var oauthUser = JSON.parse(data).data;\n      p.fulfill(oauthUser);\n    })\n    return p;\n  })\n  .convertErr( function (data) {\n    return new Error(data.error_message);\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/justintv.js":"var oauthModule = require('./oauth');\n\nmodule.exports =\noauthModule.submodule('justintv')\n\n  .apiHost('http://api.justin.tv')\n  .oauthHost('http://api.justin.tv')\n\n  .entryPath('/auth/justintv')\n  .callbackPath('/auth/justintv/callback')\n\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '/api/account/whoami.json', accessToken, accessTokenSecret, function (err, data) {\n      if (err) return promise.fail(err);\n      var oauthUser = JSON.parse(data);\n      return promise.fulfill(oauthUser);\n    });\n    return promise;\n  })\n  \n  .convertErr( function (data) {\n    return new Error(data.data);\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/ldap.js":"var passwordModule = require('./password');\nvar LdapAuth = require('ldapauth');\n\nvar ldap = module.exports =\npasswordModule.submodule('ldap')\n  .configurable({\n      ldapUrl: 'ldap server url'\n    , adminDn: 'ldap bind dn'\n    , adminPassword: 'ldap bind password'\n    , searchBase: 'ldap search base'\n    , searchFilter: 'ldap search filter'\n    , requireGroupDn: 'ldap (option) required group DN'\n  })\n  .authenticate( function (login, password, req, res) {\n    var promise = this.Promise();\n    var ldapauth = new LdapAuth({\n      url: this._ldapUrl,\n      adminDn: this._adminDn,\n      adminPassword: this._adminPassword,\n      searchBase: this._searchBase,\n      searchFilter: this._searchFilter,\n      requireGroupDn: this._requireGroupDn,\n      cache: true\n    });\n    ldapauth.authenticate(login, password, function (err, result) {\n      var user, errors;\n      if (err) {\n        // return promise.fail(err);\n        if (typeof err == 'string') {\n          return promise.fulfill(['LDAP Error: ' + err]);\n        } else {\n          return promise.fulfill(['LDAP Error: ' + err.message]);        \n        }\n      }\n      if (result === false) {\n        errors = ['Login failed.'];\n        return promise.fulfill(errors);\n      } else if (typeof result == 'object') {\n        if (result.uid == login) {\n          user = {};\n          user['id'] = login;\n          console.log(\"LDAP: positive authorization for user \" + result.uid + \"\")\n          return promise.fulfill(user);\n        } else {\n          return promise.fulfill(['LDAP Error: result does not match username', result])\n        }\n      } else {\n        console.log('ldapauth returned an unknown result:');\n        console.log(result);\n        return promise.fulfill(['Unknown ldapauth response']);        \n      }\n    });\n    return promise;\n  })\n  .addToSession( function (sess, user, errors) {\n    var _auth = sess.auth || (sess.auth = {});\n    if (user)\n      _auth.ldap = {\n        userId: user[this._userPkey]\n      };\n    _auth.loggedIn = !!user;\n  })\n  .getRegisterPath('/nonexistant/register')\n  .postRegisterPath('/nonexistant/register')\n  .registerUser( function (newUserAttributes) {});\n\n;\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/password.js":"var everyModule = require('./everymodule');\n\n/**\n * This is used to generate the render methods used with\n *\n * - `displayLogin`\n * - `respondToLoginFail`\n * - `displayRegister`\n * - `respondToRegistrationFail`\n *\n * The generated functions have the signature\n *\n *     function (req, res, *extraParams) {...}\n *\n * @param {String} type is either 'login' or 'register'\n * @param {Function} localsDefault is a function that returns the default\n * locals object. It has the signature\n *\n *     function (*extraParams) {...}\n *\n * So, for example, if the generated function can handle incoming args:\n *\n *     function render (req, res, errors, data)\n *\n * , then the `localsDefault` signature can see the params\n *\n *     function localsDefault (errors, data)\n *\n * @returns {Function} a generated render function with signature\n *\n *     function (req, res, *extraParams) {...}\n */\nfunction renderGenerator (type, localsDefault) {\n  return function render (req, res) {\n    var locals, render, layout\n      , extraLocals\n      , view = this[type + 'View'](), arity\n      , trailingArgs = Array.prototype.slice.call(arguments, 2);\n\n    if (res.render) {\n      locals = \n        localsDefault.apply(this, trailingArgs);\n      layout = this['_' + type + 'Layout'];\n      render = function render (locals) {\n        if ('undefined' !== typeof layout) {\n          locals.layout = layout;\n        }\n        res.render(view, locals);\n      };\n\n      extraLocals = this['_' + type + 'Locals'];\n      if ('function' !== typeof extraLocals) {\n        for (var k in extraLocals) {\n          locals[k] = extraLocals[k];\n        }\n        return render(locals);\n      }\n\n      arity = extraLocals.length;\n      if (arity === 2) {\n        // Dynamic sync locals\n        extraLocals = extraLocals(req, res);\n        for (var k in extraLocals) {\n          locals[k] = extraLocals[k];\n        }\n        return render(locals);\n      } else if (arity === 3) {\n        // Dynamic async locals\n        return extraLocals(req, res, function (err, extraLocals) {\n          if (err) throw err; // TODO Call global configurable error handler\n          for (var k in extraLocals) {\n            locals[k] = extraLocals[k];\n          }\n          return render(locals);\n        });\n      } else {\n        throw new Error('Your `locals` function must have arity 2 or 3');\n      }\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      if ('function' === typeof view) {\n        res.end(view.apply(this, trailingArgs));\n      } else {\n        res.end(view);\n      }\n    }\n  };\n}\n\nvar renderLogin = renderGenerator('login',\n  function () {\n    var locals = {};\n    locals[this.loginKey()] = null;\n    return locals;\n  }\n);\n\nvar renderLoginFail = renderGenerator('login',\n  function (errors, login) {\n    var locals = {errors: errors};\n    locals[this.loginKey()] = login;\n    return locals;\n  }\n);\n\nvar renderRegister = renderGenerator('register',\n  function () {\n    var locals = {};\n    locals.userParams = {};\n    return locals;\n  }\n);\n\nvar renderRegisterFail = renderGenerator('register',\n  function (errors, newUserAttributes) {\n    return {\n        errors: errors\n      , userParams: newUserAttributes};\n  }\n);\n\n/**\n * Let's define our password module\n */\nvar password = module.exports =\neveryModule.submodule('password')\n  .configurable({\n      loginFormFieldName: 'the name of the login field. Same as what you put in your login form '\n               + '- e.g., if <input type=\"text\" name=\"username\" />, then loginFormFieldName '\n               + 'should be set to \"username\".'\n    , passwordFormFieldName: 'the name of the login field. Same as what you put in your login form '\n               + '- e.g., if <input type=\"password\" name=\"pswd\" />, then passwordFormFieldName '\n               + 'should be set to \"pswd\".'\n    , loginHumanName: 'the human readable name of login -- e.g., \"login\" or \"email\"'\n    , loginKey: 'the name of the login field in your data store -- e.g., \"email\"; defaults to \"login\"'\n    , loginWith: 'specify what login type you want to use'\n    , validLoginTypes: 'specifies the different login types available and associated behavior'\n    , loginView: 'Either (A) the name of the view (e.g., \"login.jade\") or (B) the HTML string ' +\n                 'that corresponds to the login page OR (C) a function (errors, login) {...} that returns the HTML string incorporating the array of `errors` messages and the `login` used in the prior attempt'\n    , loginLayout: 'the name or path to the layout you want to use for your login'\n    , loginLocals: 'Configure extra locals to pass to your login view'\n    , loginSuccessRedirect: 'The path we redirect to after a successful login.'\n    , registerView: 'Either the name of the view (e.g., \"register.jade\") or the HTML string ' +\n                 'that corresponds to the register page.'\n    , registerLayout: 'the name or path to the layout you want to use for your registration page'\n    , registerLocals: 'Configure extra locals to pass to your register/registration view'\n    , registerSuccessRedirect: 'The path we redirect to after a successful registration.'\n  })\n  .loginFormFieldName('login')\n  .passwordFormFieldName('password')\n  .loginHumanName('login')\n  .loginKey('login')\n\n  .get('getLoginPath', \"the login page's uri path.\")\n    .step('displayLogin')\n      .accepts('req res next')\n      .promises(null)\n  .displayLogin(renderLogin)\n\n  .post('postLoginPath', \"the uri path that the login POSTs to. Same as the 'action' field of the login <form />.\")\n    .step('extractLoginPassword')\n      .accepts('req res next')\n      .promises('login password')\n    .step('authenticate')\n      .accepts('login password')\n      .promises('userOrErrors')\n    .step('interpretUserOrErrors')\n      .description('Pipes the output of the step `authenticate` into either the `user` or `errors` param')\n      .accepts('userOrErrors')\n      .promises('user errors')\n    .step('getSession')\n      .description('Retrieves the session of the incoming request and returns in')\n      .accepts('req')\n      .promises('session')\n    .step('addToSession')\n      .description('Adds the user to the session')\n      .accepts('session user errors')\n      .promises(null)\n    .step('respondToLoginSucceed') // TODO Rename to maybeRespondToLoginSucceed ?\n      .description('Execute a HTTP response for a successful login')\n      .accepts('res user')\n      .promises(null)\n    .step('respondToLoginFail')\n      .description('Execute a HTTP response for a failed login')\n      .accepts('req res errors login')\n      .promises(null)\n  .extractLoginPassword( function (req, res) {\n    return [req.body[this.loginFormFieldName()], req.body[this.passwordFormFieldName()]];\n  })\n  .interpretUserOrErrors( function (userOrErrors) {\n    if (Array.isArray(userOrErrors)) {\n      return [null, userOrErrors]; // We have an array of errors\n    } else {\n      return [userOrErrors, []]; // We have a user\n    }\n  })\n  .getSession( function (req) {\n    return req.session;\n  })\n  .addToSession( function (sess, user, errors) {\n    var _auth = sess.auth || (sess.auth = {});\n    if (user)\n      _auth.userId = user[this._userPkey];\n    _auth.loggedIn = !!user;\n  })\n  .respondToLoginSucceed( function (res, user) {\n    if (user) {\n      this.redirect(res, this.loginSuccessRedirect());\n    }\n  })\n  .respondToLoginFail( function (req, res, errors, login) {\n    if (!errors || !errors.length) return;\n    return renderLoginFail.apply(this, arguments);\n  })\n\n  .get('getRegisterPath', \"the registration page's uri path.\")\n    .step('displayRegister')\n      .accepts('req res next')\n      .promises(null)\n  .displayRegister( function (req, res) {\n    return renderRegister.apply(this, arguments);\n  })\n\n  .post('postRegisterPath', \"the uri path that the registration POSTs to. Same as the 'action' field of the registration <form />.\")\n    .step('extractLoginPassword') // Re-used (/search for other occurence)\n    .step('extractExtraRegistrationParams')\n      .description('Extracts additonal query or body params from the ' + \n                   'incoming request and returns them in the `extraParams` object')\n      .accepts('req')\n      .promises('extraParams')\n    .step('aggregateParams')\n      .description('Combines login, password, and extraParams into a newUserAttributes Object containing everything in extraParams plus login and password key/value pairs')\n      .accepts('login password extraParams')\n      .promises('newUserAttributes')\n    .step('validateRegistrationBase')\n      .description(\"Basic validation done by `everyauth`. Don't edit this. Configure validateRegistration instead.\")\n      .accepts('newUserAttributes')\n      .promises('baseErrors')\n    .step('validateRegistration')\n      .description('Validates the registration parameters. Default includes check for existing user')\n      .accepts('newUserAttributes baseErrors')\n      .promises('errors')\n    .step('maybeBreakToRegistrationFailSteps')\n      .accepts('req res errors newUserAttributes')\n      .promises(null)\n      .canBreakTo('registrationFailSteps')\n    .step('registerUser')\n      .description('Creates and returns a new user with newUserAttributes')\n      .accepts('newUserAttributes')\n      .promises('userOrErrors')\n    .step('extractUserOrHandleErrors') // User registration may throw an error if DB detects a non-unique value for login\n      .accepts('req res userOrErrors newUserAttributes')\n      .promises('user')\n      .canBreakTo('registrationFailSteps')\n    .step('getSession')\n    .step('addToSession')\n    .step('respondToRegistrationSucceed')\n      .accepts('req res user')\n      .promises(null)\n  .extractExtraRegistrationParams( function (req) {\n    return {};\n  })\n  .aggregateParams( function (login, password, extraParams) {\n    var params = extraParams;\n    params[this.loginKey()] = login;\n    params.password = password;\n    return params;\n  })\n  .validateRegistrationBase( function (newUserAttributes) {\n    var loginWith = this.loginWith()\n      , loginWithSpec, loginWithSanitize, loginWithValidate\n      , login = newUserAttributes[this.loginKey()]\n      , password = newUserAttributes.password\n      , errors = [];\n    if (!login) {\n      errors.push('Missing ' + this.loginHumanName());\n    } else {\n      // loginWith specific validations\n      var validLoginTypes = this.validLoginTypes();\n      loginWithSpec = this.validLoginTypes()[loginWith];\n\n      // Sanitize first\n      loginWithSanitize = loginWithSpec.sanitize;\n      if (loginWithSanitize) {\n        login = loginWithSanitize(login);\n      }\n\n      // Validate second\n      var validateLoginWith = loginWithSpec.validate;\n      if (validateLoginWith) {\n        if (!validateLoginWith(login)) {\n          // Add error third\n          errors.push(loginWithSpec.error);\n        }\n      }\n    }\n    if (!password) errors.push('Missing password');\n    return errors;\n  })\n  .validateRegistration( function (newUserAttributes, baseErrors) {\n    return baseErrors;\n  })\n  .maybeBreakToRegistrationFailSteps( function (req, res, errors, newUserAttributes) {\n    var user, loginField, loginKey;\n    if (errors && errors.length) {\n      user = newUserAttributes;\n      loginField = this.loginFormFieldName();\n      loginKey = this.loginKey();\n      if (loginField !== loginKey) {\n        user[loginField] = user[loginKey];\n        delete user[this.loginKey()];\n      }\n      delete user.password;\n      return this.breakTo('registrationFailSteps', req, res, errors, user);\n    }\n  })\n  .extractUserOrHandleErrors( function (req, res, userOrErrors, newUserAttributes) {\n    var errors, user;\n    if (Array.isArray(userOrErrors)) {\n      errors = userOrErrors;\n      user = newUserAttributes;\n      delete user.password;\n      return this.breakTo('registrationFailSteps', req, res, errors, user);\n    }\n    user = userOrErrors;\n    return user;\n  })\n  .respondToRegistrationSucceed( function (req, res, user) {\n    this.redirect(res, this.registerSuccessRedirect());\n  })\n\n  .stepseq('registrationFailSteps')\n    .step('respondToRegistrationFail')\n      .accepts('req res errors newUserAttributes')\n      .promises(null)\n  .respondToRegistrationFail( function (req, res, errors, newUserAttributes) {\n    return renderRegisterFail.apply(this, arguments);\n  });\n\nfunction validateEmail (value) {\n  // From Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/\n  var isValid = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$/i.test(value);\n\n  return isValid;\n}\n\npassword.validLoginTypes({\n    login: {}\n  , email: {\n        validate: validateEmail\n      , error: 'Please correct your email.'\n    }\n  , phone: {\n        sanitize: function (value) {\n          // Pull out only +, digits and 'x' for extension\n          return value.replace(/[^\\+\\dx]/g, '');\n        }\n      , validate: function (value) {\n          return value.length >= 7;\n        }\n      , error: 'Please correct your phone.'\n    }\n});\n\npassword.loginWith = function (loginType) {\n  if (!arguments.length) return this._loginType;\n\n  this._loginType = loginType;\n  var name\n    , validLoginTypes = Object.keys(this.validLoginTypes());\n  if (-1 === validLoginTypes.indexOf(loginType)) {\n    throw new Error(\"loginWith only supports \" + validLoginTypes.join(', '));\n  }\n  this.loginFormFieldName(loginType);\n  this.loginKey(loginType);\n  this.loginHumanName(loginType);\n  return this;\n};\npassword.loginWith('login');\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/linkedin.js":"var oauthModule = require('./oauth')\n  , OAuth = require('oauth').OAuth;\n\nvar linkedin = module.exports =\noauthModule.submodule('linkedin')\n  .definit( function () {\n    this.oauth = new OAuth(\n        this.oauthHost() + this.requestTokenPath()\n      , this.oauthHost() + this.accessTokenPath()\n      , this.consumerKey()\n      , this.consumerSecret()\n      , '1.0', null, 'HMAC-SHA1', null\n      , {\n            Accept: '/'\n          , Connection: 'close'\n          , 'User-Agent': 'Node authentication'\n          , 'x-li-format': 'json' // So we get JSON responses\n        });\n  })\n\n  .configurable({\n    fields: 'List of fields to retrieve from the profile. See http://developer.linkedin.com/documents/profile-fields'\n  })\n  .apiHost('https://api.linkedin.com/v1')\n  .oauthHost('https://api.linkedin.com')\n\n  .requestTokenPath('/uas/oauth/requestToken')\n  .authorizePath('/uas/oauth/authenticate')\n  .accessTokenPath('/uas/oauth/accessToken')\n  .fields('id,first-name,last-name,headline,location:(name,country:(code)),industry,num-connections,num-connections-capped,summary,specialties,proposal-comments,associations,honors,interests,positions,publications,patents,languages,skills,certifications,educations,three-current-positions,three-past-positions,num-recommenders,recommendations-received,phone-numbers,im-accounts,twitter-accounts,date-of-birth,main-address,member-url-resources,picture-url,site-standard-profile-request:(url),api-standard-profile-request:(url,headers),public-profile-url')\n\n  .entryPath('/auth/linkedin')\n  .callbackPath('/auth/linkedin/callback')\n\n  .redirectToProviderAuth( function (res, token) {\n    this.redirect(res, 'https://www.linkedin.com' + this.authorizePath() + '?oauth_token=' + token);\n  })\n\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '/people/~:(' + this.fields() + ')', accessToken, accessTokenSecret, function (err, data, res) {\n      if (err) {\n        err.extra = {data: data, res: res}\n        return promise.fail(err);\n      }\n      var oauthUser = JSON.parse(data);\n      promise.fulfill(oauthUser);\n    });\n    return promise;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var linkedInResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          linkedInResponse.statusCode\n        , linkedInResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/mailchimp.js":"var oauthModule = require('./oauth2')\n  , request = require('request');\n\nvar mailchimp = module.exports =\noauthModule.submodule('mailchimp')\n  .configurable({\n    metadataPath: \"Although this shouldn't be changed, this is where we get the datacenter for building the API key.\"\n  })\n  .oauthHost('https://login.mailchimp.com')\n  .authPath('/oauth2/authorize')\n  .accessTokenPath('/oauth2/token')\n  .metadataPath('/oauth2/metadata')\n\n  .entryPath('/auth/mailchimp')\n  .callbackPath('/auth/mailchimp/callback')\n  .fetchOAuthUser( function (accessToken) {\n    var promise = this.Promise();\n    this.oauth._request(\"GET\", this.oauthHost() + this.metadataPath(), {\n      Authorization: 'OAuth ' + accessToken\n    },\"\",\"\", function (err, data){\n      if (err) return promise.fail(err);\n\n      var metadata = JSON.parse(data)\n        , apikey = accessToken + \"-\"+ metadata.dc;\n\n      request.post({\n          url: metadata.api_endpoint + '/1.3/?method=getAccountDetails'\n        , form: {apikey: apikey}\n      }, function (err, res, body) {\n        if (err) {\n          err.extra = {res: res, data: body};\n          return promise.fail(err);\n        }\n        if (parseInt(res.statusCode/100, 10) !== 2) {\n          return promise.fail({extra: {data: body, res: res}});\n        }\n        var oauthUser = JSON.parse(body);\n        oauthUser.apikey = apikey;\n        return promise.fulfill(oauthUser);\n      });\n    });\n    return promise;\n  })\n  .postAccessTokenParamsVia(\"data\")\n  .authQueryParam('response_type','code')\n  .accessTokenParam('grant_type','authorization_code')\n\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var mailchimpResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          mailchimpResponse.statusCode\n        , mailchimpResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/mailru.js":"var oauthModule = require('./oauth2')\n, url = require('url')\n, fs = require('fs')\n, crypto = require('crypto');\n\nvar mailru = module.exports =\noauthModule.submodule('mailru')\n.configurable({\n    display: 'set to \"mobile\" if you want users to see a mobile optimized version of the auth page',\n    scope:  'specify types of access: See http://api.mail.ru/docs/guides/restapi/#permissions'\n})\n.oauthHost('https://connect.mail.ru')\n.apiHost('http://www.appsmail.ru/platform/api')\n.entryPath('/auth/mailru')\n.callbackPath('/auth/mailru/callback')\n\n.authQueryParam('display', function () {\n    return this._display && this.display();\n})\n.authQueryParam('response_type', 'code')\n.authQueryParam('scope', function () {\n    return this._scope && this.scope();\n})\n\n.accessTokenParam('grant_type', 'authorization_code')\n.accessTokenHttpMethod('post')\n.postAccessTokenParamsVia('data')\n.accessTokenPath('/oauth/token')\n\n.fetchOAuthUser( function (accessToken, http) {\n    var promise = this.Promise(),\n    extradata = http.extra;\n\n    if(typeof accessToken === 'undefined'){\n        if(typeof extradata.access_token === 'undefined') {\n            var strextra = JSON.stringify(extradata).replace(/^\\{\"(.*)\":\"\"\\}$/,'\"$1\"'),\n            extra = eval('(' + JSON.parse(strextra) + ')');\n            accessToken = extra.access_token;\n        } else {\n            accessToken = extra.access_token;\n        }\n    }\n\n    var query = {\n        app_id: this.appId(),\n        method: 'users.getInfo',\n        secure:1,\n        session_key: accessToken\n    },\n    data = '',\n    fields = [];\n\n    for ( key in query ) {\n        data += key + '=' + query[key];\n    }\n    data += this.appSecret();\n    query.sig = crypto.createHash('md5').update(data).digest(\"hex\");\n\n    for ( key in query ) {\n        fields.push(key + '=' + query[key]);\n    }\n\n    this.oauth.get(this.apiHost() + '?' + fields.join('&'), accessToken, function (err, data) {\n        if (err) {\n            if (err.error) {\n                promise.fail(err.error.error_msg)\n            }\n            else {\n                promise.fail(err.error_message);\n            }\n        }\n        var data = JSON.parse(data);\n        if (data.error) {\n            promise.fail(data.error.error_msg)\n        }\n        else {\n            var oauthUser = data[0];\n            promise.fulfill(oauthUser);\n        }\n    });\n    return promise;\n})\n\n.authCallbackDidErr(function(req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n})\n\n.convertErr( function (data) {\n    return new Error(JSON.parse(data).error.error_msg);\n});\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/mendeley.js":"var oauthModule = require('./oauth'),\n    OAuth = require('oauth').OAuth;\n\tvar mendeley = module.exports =\n\toauthModule.submodule('mendeley')\n\t\n  // http://apidocs.mendeley.com/home/authentication\n\t.apiHost('http://api.mendeley.com/oapi')\n  .oauthHost('http://www.mendeley.com/oauth')\n\n  .requestTokenPath('/request_token/')\n\t.accessTokenPath('/access_token/')\n  .authorizePath('/authorize/')\n\n  // oauth_callback not allowed\n  .sendCallbackWithAuthorize(false)\n\n  .entryPath('/auth/mendeley')\n  .callbackPath('/auth/mendeley/callback')\n  .definit( function () {\n    this.oauth = new OAuth(\n        this.oauthHost() + this.requestTokenPath()\n      , this.oauthHost() + this.accessTokenPath()\n      , this.consumerKey()\n      , this.consumerSecret()\n      , '1.0', null, 'HMAC-SHA1');\n\n    // Mendeley does not support POST requests\n    this.oauth.setClientOptions({\n      \"requestTokenHttpMethod\": \"GET\",\n      \"accessTokenHttpMethod\": \"GET\"\n    });\n  })\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/profiles/info/me/', accessToken, accessTokenSecret, function (err, data) {\n      if (err) return p.fail(err.error_message);\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    })\n    return p;\n  })\n  .convertErr( function (data) {\n    return new Error(data.error_message);\n  });\n  \n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/mixi.js":"var oauthModule = require('./oauth2')\n  , url = require('url');\n\nvar mixi = module.exports =\noauthModule.submodule('mixi')\n  .configurable({\n      scope: 'specify types of access: See http://developers.mixi.co.jp/'\n    , display: 'specify types of access: See http://developers.mixi.co.jp/'\n  })\n\n  .apiHost('https://api.mixi-platform.com/2')\n  .oauthHost('https://secure.mixi-platform.com/2/token')\n\n  .accessTokenPath('https://secure.mixi-platform.com/2/token')\n\n  .authPath('https://mixi.jp/connect_authorize.pl')\n\n  .entryPath('/auth/mixi')\n  .callbackPath('/auth/mixi/callback')\n\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n  .authQueryParam('response_type', function () {\n    return 'code';\n  })\n  .authQueryParam('display', function () {\n    return this._display && this.display();\n  })\n\n  .accessTokenParam('grant_type', function () {\n    return 'authorization_code';\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true)\n      , errorDesc = parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n    this.oauth.setAccessTokenName('oauth_token');\n    this.oauth.get(this.apiHost() + '/people/@me/@self', accessToken, function (err, data) {\n      if (err){\n        return p.fail(err);\n      }\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    })\n    return p;\n  })\n  .convertErr( function (data) {\n    return new Error(JSON.parse(data.data).error.message);\n  });\n\nmixi.mobile = function (isMobile) {\n  if (isMobile) {\n    this.authPath('https://m.mixi.jp/connect_authorize.pl');\n  }\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/osm.js":"var oauthModule = require('./oauth')\n  , url = require('url')\n  , Parser = require('xml2js').Parser\n  , parser = new Parser({ mergeAttrs: true });\n\nvar osm = module.exports =\noauthModule.submodule('osm')\n  .apiHost('http://api.openstreetmap.org')\n  .oauthHost('http://www.openstreetmap.org')\n  .entryPath('/auth/osm')\n  .callbackPath('/auth/osm/callback')\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '/api/0.6/user/details', accessToken, accessTokenSecret, function (err, data) {\n      if (err) return promise.fail(err);\n      parser.parseString(data, function (err, result) {\n        if (err) return promise.fail(err);\n        var oauthUser = result.user;\n        promise.fulfill(oauthUser);\n      });\n    });\n    return promise;\n  })\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.denied;\n  })\n  .handleAuthCallbackError( function (req, res) {\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: 'The user denied your request'\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n  .convertErr( function (data) {\n    return new Error(data.data.match(/<error>(.+)<\\/error>/)[1]);\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/readability.js":"var oauthModule = require('./oauth');\n\n\tvar readability = module.exports =\n\toauthModule.submodule('readability')\n\t\n\t.apiHost('https://www.readability.com/api/rest/v1')\n  .oauthHost('https://www.readability.com/api/rest/v1/oauth')\n\n  .requestTokenPath('/request_token')\n\t.authorizePath('/authorize')\n\t.accessTokenPath('/access_token')\n\n  .entryPath('/auth/readability')\n  .callbackPath('/auth/readability/callback')\n\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/users/_current', accessToken, accessTokenSecret, function (err, data) {\n      if (err) return p.fail(err.error_message);\n      var oauthUser = JSON.parse(data);\n      p.fulfill(oauthUser);\n    })\n    return p;\n  })\n  .convertErr( function (data) {\n    return new Error(data.error_message);\n  });\n  \n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/salesforce.js":"var oauthModule = require('./oauth2'),\n    url = require('url'),\n    request = require('request');\n\nvar salesforce = module.exports =\noauthModule.submodule('salesforce')\n\n  .configurable({\n    scope: \"A space seperated list of scope values of Salesforce scopes to be accessed.  See the documentation to determine what scope you'd like to specify.  If not specified, it will default to: api refresh_token\"\n  })\n\n  .oauthHost('https://login.salesforce.com')\n  .apiHost('https://login.salesforce.com')\n\n  .authPath('/services/oauth2/authorize')\n  .authQueryParam('response_type', 'code')\n\n  .accessTokenPath('/services/oauth2/token')\n  .accessTokenParam('grant_type', 'authorization_code')\n  .accessTokenHttpMethod('post')\n  .postAccessTokenParamsVia('data')\n\n  .entryPath('/auth/salesforce')\n  .callbackPath('/auth/salesforce/callback')\n\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true),\n        errorDesc = parsedUrl.query.error + \"; \" + parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken, authResponse) {\n    var p = this.Promise();\n\n    request.get({\n      url: authResponse.extra.id,\n      headers: {'Authorization': 'Bearer ' + accessToken}\n    }, function(err, res, body) {\n      if(err){\n        return p.fail(err);\n      } else {\n        if(parseInt(res.statusCode/100,10) !=2) {\n          return p.fail({extra:{data:body, res: res}});\n        }\n        var oAuthUser = JSON.parse(body);\n        p.fulfill(oAuthUser);\n      }\n    });\n\n    return p;\n  })\n\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var salesforceResponse = err.extra.res,\n          serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          salesforceResponse.statusCode,\n          salesforceResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/shopify.js":"var oauthModule = require('./oauth2');\n\nvar shopify = module.exports =\noauthModule.submodule('shopify')\n  .configurable({\n    // oauthHost & apiHost set at runtime, since they depend on the shop endpoint\n    apiHost: 'https://SHOP_NAME.myshopify.com/'\n    , oauthHost: 'https://SHOP_NAME.myshopify.com/'\n    , appId: 'API key in your App Info'\n    , appSecret: 'Shared Secret from your App Info'\n    , scope: 'types of access. See Shopify API docs for scopes available. Expects \"read_products,write_themes\"'\n  })\n\n  // oauthHost & apiHost set at runtime, since they depend on the shop endpoint\n\n  .entryPath('/auth/shopify')\n\n  .authPath('/admin/oauth/authorize')\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .accessTokenPath('/admin/oauth/access_token')\n\n  .callbackPath('/auth/shopify/callback')\n\n  .fetchOAuthUser( function (accessToken) {\n    var p = this.Promise();\n    this.oauth.get(this.apiHost() + '/admin/shop.json', accessToken, function (err, data, res) {\n      if (err) {\n        err.extra = {data: data, res: res};\n        return p.fail(err);\n      }\n      var shop = JSON.parse(data).shop;\n      p.fulfill(shop);\n    });\n    return p;\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var shopifyResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          shopifyResponse.statusCode\n        , shopifyResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/skyrock.js":"var oauthModule = require('./oauth')\n\t, Parser = require('xml2js').Parser;\n\nvar skyrock = module.exports =\n\toauthModule.submodule('skyrock')\n\t\t.apiHost('https://api.skyrock.com/v2')\n\t\t.oauthHost('https://api.skyrock.com/v2')\n\t\t.requestTokenPath(\"/oauth/initiate\")\n\t\t.accessTokenPath(\"/oauth/token\")\n\t\t.authorizePath(\"/oauth/authorize\")\n\t\t.entryPath('/auth/skyrock')\n\t\t.callbackPath('/auth/skyrock/callback')\n\t\t.sendCallbackWithAuthorize(false)\n\t\t.fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n\t\t\tvar promise = this.Promise();\n\t\t\tthis.oauth.get(this.apiHost() + '/user/get.json', accessToken, accessTokenSecret, function (err, data) {\n\t\t\t\tdata = JSON.parse(data);\n\t\t\t\tpromise.fulfill(data);\n\t\t\t});\n\t\t\treturn promise;\n\t\t})\n\t\t.convertErr( function (data) {\n\t\t\treturn data.data;\n\t\t});\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/soundcloud.js":"var oauthModule = require('./oauth2')\n  , request = require('request');\n\nvar soundcloud = module.exports =\noauthModule.submodule('soundcloud')\n  .configurable({\n      scope: 'specify types of access: (no scope), non-expiring'\n    , display: 'specify type of auth dialog: (no display), popup'\n  })\n  .apiHost('https://api.soundcloud.com')\n  .oauthHost('https://api.soundcloud.com')\n  .authPath('/connect')\n  .accessTokenPath('/oauth2/token')\n  .entryPath('/auth/soundcloud')\n  .callbackPath('/auth/soundcloud/callback')\n  .authQueryParam('response_type', 'code')\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n  .authQueryParam('display', function () {\n    return this._display && this.display();\n  })\n  .accessTokenHttpMethod('post')\n  .postAccessTokenParamsVia('data')\n  .accessTokenParam('grant_type', 'authorization_code')\n  .fetchOAuthUser(function (accessToken) {\n    var promise = this.Promise();\n    request.get({\n        url: this.apiHost() + '/me.json'\n      , qs: {oauth_token: accessToken}\n    }, function (err, res, body) {\n      if (err) return promise.fail(err);\n      if (parseInt(res.statusCode / 100, 10) !== 2) {\n        return promise.fail(body);\n      }\n      return promise.fulfill(JSON.parse(body));\n    });\n\n    return promise;\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/stripe.js":"var oauthModule = require('./oauth2'),\n    url = require('url'),\n    request = require('request');\n\nvar stripe = module.exports =\noauthModule.submodule('stripe')\n\n  .configurable({\n    scope: \"A space seperated list of scope values of Stripe scopes to be accessed.  See the documentation to determine what scope you'd like to specify.  If not specified, it will default to: read_only\",\n    landing: \"Set to login or register depending on what type of screen you want your users to see.  Defaults to login scope for read_only and register for scope for read_write\"\n  })\n\n  .oauthHost('https://connect.stripe.com')\n  .apiHost('https://api.stripe.com')\n\n  .authPath('/oauth/authorize')\n  .authQueryParam('response_type', 'code')\n\n  .authQueryParam('stripe_landing', function () {\n    return this._landing && this.landing();\n  })\n\n  .accessTokenPath('/oauth/token')\n  .accessTokenParam('grant_type', 'authorization_code')\n  .accessTokenHttpMethod('post')\n\n  .entryPath('/auth/stripe')\n  .callbackPath('/auth/stripe/callback')\n\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n\n  .handleAuthCallbackError( function (req, res) {\n    var parsedUrl = url.parse(req.url, true),\n        errorDesc = parsedUrl.query.error + \"; \" + parsedUrl.query.error_description;\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: errorDesc\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n\n  .fetchOAuthUser( function (accessToken, authResponse) {\n    //var user = authResponse;\n    var p = this.Promise();\n\n    request.get({\n      url: this.apiHost() + '/v1/account',\n      headers: {'Authorization': 'Bearer ' + accessToken}\n    }, function(err, res, body) {\n      if(err){\n        return p.fail(err);\n      } else {\n        if(parseInt(res.statusCode/100,10) !=2) {\n          return p.fail({extra:{data:body, res: res}});\n        }\n        var oAuthUser = JSON.parse(body);\n        p.fulfill(oAuthUser);\n      }\n    });\n    return p;\n  })\n\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var stripeResponse = err.extra.res, \n          serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          stripeResponse.statusCode, \n          stripeResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/tripit.js":"var oauthModule = require('./oauth')\n  , url = require('url');\n\nvar tripitModule = module.exports =\noauthModule.submodule('tripit')\n  .apiHost('https://api.tripit.com')\n  .oauthHost('https://api.tripit.com')\n  .entryPath('/auth/tripit')\n  .callbackPath('/auth/tripit/callback')\n  .redirectToProviderAuth( function (res, token) {\n    var redirectTo = 'https://www.tripit.com' + this.authorizePath() + '?oauth_token=' + token;\n    if (this.sendCallbackWithAuthorize()) {\n      redirectTo += '&oauth_callback=' + this.myHostname() + this.callbackPath();\n    }\n    this.redirect(res, redirectTo);\n  })\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '/v1/get/profile/id/' + params.user_id + '/format/json',\n        accessToken, accessTokenSecret, function (err, data) {\n      if (err) {\n        return promise.fail(err);\n      }\n      var oauthUser = JSON.parse(data).Profile;\n      promise.fulfill(oauthUser);\n    });\n    return promise;\n  })\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.denied;\n  })\n  .handleAuthCallbackError( function (req, res) {\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: 'The user denied your request'\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n  .convertErr( function (data) {\n    return new Error(data.data.match(/<error>(.+)<\\/error>/)[1]);\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/tumblr.js":"var oauthModule = require('./oauth')\n  , Parser = require('xml2js').Parser;\n\nvar t = module.exports =\noauthModule.submodule('tumblr')\n  .apiHost('https://api.tumblr.com/v2')\n  .oauthHost('https://www.tumblr.com')\n  .entryPath('/auth/tumblr')\n  .callbackPath('/auth/tumblr/callback')\n  .sendCallbackWithAuthorize(false)\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '/user/info', accessToken, accessTokenSecret, function (err, data) {\n      if (err) return promise.fail(err);\n      var oauthUser = JSON.parse(data);\n      promise.fulfill(oauthUser);\n    });\n    return promise;\n  })\n  .convertErr( function (data) {\n    return data.data;\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/twitter.js":"var oauthModule = require('./oauth')\n  , url = require('url');\n\nvar twitter = module.exports =\noauthModule.submodule('twitter')\n  .apiHost('https://api.twitter.com')\n  .oauthHost('https://api.twitter.com')\n  .entryPath('/auth/twitter')\n  .callbackPath('/auth/twitter/callback')\n  .authorizePath('/oauth/authenticate')\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '/1.1/users/show.json?user_id=' + params.user_id, accessToken, accessTokenSecret, function (err, data, res) {\n      if (err) {\n        err.extra = {data: data, res: res};\n        return promise.fail(err);\n      }\n      var oauthUser = JSON.parse(data);\n      promise.fulfill(oauthUser);\n    });\n    return promise;\n  })\n  .authCallbackDidErr( function (req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.denied;\n  })\n  .handleAuthCallbackError( function (req, res) {\n    if (res.render) {\n      res.render(__dirname + '/../views/auth-fail.jade', {\n        errorDescription: 'The user denied your request'\n      });\n    } else {\n      // TODO Replace this with a nice fallback\n      throw new Error(\"You must configure handleAuthCallbackError if you are not using express\");\n    }\n  })\n  .moduleErrback( function (err, seqValues) {\n    if (err instanceof Error) {\n      var next = seqValues.next;\n      return next(err);\n    } else if (err.extra) {\n      var twitterResponse = err.extra.res\n        , serverResponse = seqValues.res;\n      serverResponse.writeHead(\n          twitterResponse.statusCode\n        , twitterResponse.headers);\n      serverResponse.end(err.extra.data);\n    } else if (err.statusCode) {\n      var serverResponse = seqValues.res;\n      serverResponse.writeHead(err.statusCode);\n      serverResponse.end(err.data);\n    } else {\n      console.error(err);\n      throw new Error('Unsupported error type');\n    }\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/vimeo.js":"var oauthModule = require('./oauth');\n\nvar vimeo = module.exports =\noauthModule.submodule('vimeo')\n\n  .apiHost('http://vimeo.com/api/rest/v2')\n  .oauthHost('http://vimeo.com')\n\n  .entryPath('/auth/vimeo')\n  .callbackPath('/auth/vimeo/callback')\n\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '?format=json&method=vimeo.people.getInfo&user_id=' + accessTokenSecret, accessToken, accessTokenSecret, function (err, data) {\n      if (err) return promise.fail(err);\n      var oauthUser = JSON.parse(data);\n      return promise.fulfill(oauthUser.person);\n    });\n    return promise;\n  });\n","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/vkontakte.js":"var oauthModule = require('./oauth2')\n  , url = require('url');\n\nvar vkontakte = module.exports =\noauthModule.submodule('vkontakte')\n  .configurable({\n      display: 'set to \"touch\" if you want users to see a mobile optimized version of the auth page'\n    , scope: 'specify types of access: See http://vk.com/developers.php?oid=-1&p=Права_доступа_приложений'\n    , fields: 'specify fields of profile: See http://vk.com/developers.php?oid=-1&p=Описание_полей_параметра_fields'\n  })\n\n  .oauthHost('https://api.vk.com')\n  .apiHost('https://api.vk.com')\n  .entryPath('/auth/vkontakte')\n  .callbackPath('/auth/vkontakte/callback')\n\n  .authQueryParam('response_type', 'code')\n\n  .authQueryParam('display', function () {\n    return this._display && this.display();\n  })\n  .authQueryParam('scope', function () {\n    return this._scope && this.scope();\n  })\n\n  .fetchOAuthUser( function (accessToken, http) {\n    var promise = this.Promise();\n    var params = this._fields && this.fields();\n    var fields = (params) ? '&fields=' + params : '';\n    this.oauth.get(this.apiHost() + '/method/getProfiles?uids=' + http.extra.user_id + fields, accessToken, function (err, data) {\n      if (err) return promise.fail(err.error_message);\n      var data = JSON.parse(data)\n      if (data.error) return promise.fail(data.error.error_msg);\n      var oauthUser = data.response[0];\n      promise.fulfill(oauthUser);\n    })\n    return promise;\n  })\n\n  .authCallbackDidErr(function(req) {\n    var parsedUrl = url.parse(req.url, true);\n    return parsedUrl.query && !!parsedUrl.query.error;\n  })\n\n  .convertErr( function (data) {\n    return new Error(JSON.parse(data).error.error_msg);\n  });","/home/travis/build/npmtest/node-npmtest-everyauth/node_modules/everyauth/lib/modules/yahoo.js":"var oauthModule = require('./oauth')\n  , OAuth = require('oauth').OAuth;\n\nvar yahoo = module.exports =\noauthModule.submodule('yahoo')\n  .definit( function () {\n    var oauth = this.oauth = new OAuth(\n        this.oauthHost() + this.requestTokenPath()\n      , this.oauthHost() + this.accessTokenPath()\n      , this.consumerKey()\n      , this.consumerSecret()\n      , '1.0', null, 'HMAC-SHA1');\n  })\n  .apiHost('http://social.yahooapis.com/v1')\n  .oauthHost('https://api.login.yahoo.com/oauth/v2')\n\n  .requestTokenPath('/get_request_token')\n  .accessTokenPath('/get_token')\n  .authorizePath('/request_auth')\n\n  .entryPath('/auth/yahoo')\n  .callbackPath('/auth/yahoo/callback')\n\n  .fetchOAuthUser( function (accessToken, accessTokenSecret, params) {\n    var promise = this.Promise();\n    this.oauth.get(this.apiHost() + '/user/' + params.xoauth_yahoo_guid + '/profile?format=json', accessToken, accessTokenSecret, function (err, data) {\n      if (err) return promise.fail(err);\n      var oauthUser = JSON.parse(data).profile;\n      promise.fulfill(oauthUser);\n    });\n    return promise;\n  });\n"}